[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "블로그",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nWSL2/Ubuntu\n\n\n\n\n\n\nWSL2\n\n\nUbuntu\n\n\nsetup\n\n\n\nWSL2 및 Ubuntu 설치\n\n\n\n\n\nNov 16, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCMTK\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\nopen source 이용한 반자동화\n\n\n\n\n\nMar 4, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOrthanc\n\n\n\n\n\n\ndicom server\n\n\nOrthanc\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nConquest\n\n\n\n\n\n\ndicom server\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDocker\n\n\n\n\n\n\ndocker\n\n\n\nUbuntu에 Docker 설치 및 사용법\n\n\n\n\n\nMar 9, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n개발기록\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\n\n개발과정을 기록하여 나의 기억과 협업에 도움이 되고자 함\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpen Source\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\n오픈소스들을 이용한 선량추출 시스템 구축과정을 기록\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpen Source\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\n오픈소스들을 이용한 선량추출 시스템 구축과정을 기록\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSpeficifCharactorSet decoding\n\n\n\n\n\n\nNMDose\n\n\nDICOM\n\n\nSpecificCharactorSet\n\n\ndecoding\n\n\n\nNMDose 개발 중 DICOM SpeficifCharactorSet decoding 오류 해결하기\n\n\n\n\n\nFeb 25, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nNMDose\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nNMDose\n\n\n\nNMDose 개발과정기록\n\n\n\n\n\nFeb 19, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nStandardization\n\n\n\n\n\n\nDICOM\n\n\n\n핵릐학 검사명칭 표준화\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nKNMIP\n\n\n\n\n\n\nstandardization\n\n\nKNMIP\n\n\n\nKorea Nuclear Medicine Imaging Proceudure Version v1.0\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nChocolatey\n\n\n\n\n\n\nWindown\n\n\nChocolatey\n\n\nsetup\n\n\n\n설치\n\n\n\n\n\nApr 15, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCM4chee\n\n\n\n\n\n\nDCM4chee\n\n\n\nDCM4che로 구현한 open source PACS\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nProcedure\n\n\n\n\n\n\nstandardization\n\n\nprocedure\n\n\n\n표준 검사명칭\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nConformance\n\n\n\n\n\n\nDICOM\n\n\nConformance\n\n\n\nDICOM Conformance\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n구조\n\n\n\n\n\n\nDICOM\n\n\nstructure\n\n\n\nDICOM 파일의 구조\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDICOM\n\n\n\n\n\n\nDICOM\n\n\n\nDICOM 공부한 것을 정리하였습니다.\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCM4che\n\n\n\n\n\n\nDCM4che\n\n\n\nDCM4che toolkit\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDocker\n\n\n\n\n\n\ndocker\n\n\n\nUbuntu에 Docker 설치 및 사용법\n\n\n\n\n\nMar 9, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSlicer\n\n\n\n\n\n\ndicom server\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nTools\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\nopen source 이용한 반자동화\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nPostgreSQL\n\n\n\n\n\n\ntools\n\n\nopen source\n\n\ndatabase\n\n\nPostgreSQL\n\n\n\ndatabase open source\n\n\n\n\n\nMar 5, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpenREM\n\n\n\n\n\n\ndeveolpment\n\n\ndicom\n\n\ndose extrator\n\n\nopen source\n\n\nOpenREM\n\n\n\nDICOM에서 선량정보 추출 open source\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSDKMAN\n\n\n\n\n\n\nJAVA\n\n\n\n개발도구 관리툴\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDicoogle\n\n\n\n\n\n\ndicom server\n\n\nDicoogle\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDoseUtility\n\n\n\n\n\n\ndeveolpment\n\n\ndicom\n\n\ndose extrator\n\n\nopen source\n\n\nDoseUtility\n\n\n\nDICOM에서 선량정보 추출 open source\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n사이트사용법\n\n\n\n\n\n\n사용법\n\n\n\n이 웹사이트 고유의 사용법이 설명되어 있습니다.\n\n\n\n\n\nDec 20, 2024\n\n\nBenKorea\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/tools/dicoogle.html",
    "href": "posts/tools/dicoogle.html",
    "title": "Dicoogle",
    "section": "",
    "text": "구축 필요성\n개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.\n\n\nSicoogle",
    "crumbs": [
      "Tools",
      "Dicoogle"
    ]
  },
  {
    "objectID": "posts/tools/dcm4chee.html",
    "href": "posts/tools/dcm4chee.html",
    "title": "DCM4chee",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host\n\n\n\n\ndocker compose랑 달라서 -이 있는 형태를 설치해야 합니다.\n\n\n\n\nbash\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n\n\n\n\nslapd-dcm4chee, postgres-dcm4chee, dcm4chee-arc 매뉴얼 uid, gid가 999를 넘거나 이미 존재하고 있어, 옵션에 해당하는 이부분을 굳이 변경하여 문제를 일으킬 가능성을 고려하여 설정하지 않고 skip 하였습니다.\nsudo -i 명령으로 프롬프트가 #로 바뀔 수 있음을 주의해야 합니다.\n\n\n\n\nbash\n\n$ sudo -i\ngroupadd -r slapd-dcm4chee --gid=1021 && useradd -r -g slapd-dcm4chee --uid=1021 slapd-dcm4chee\ngroupadd -r postgres-dcm4chee --gid=999 && useradd -r -g postgres-dcm4chee --uid=999 postgres-dcm4chee\ngroupadd -r dcm4chee-arc --gid=1023 && useradd -r -g dcm4chee-arc --uid=1023 dcm4chee-arc\nexit\n\n\n\n\n\n\n\n\nbash\n\nmkdir dcm4chee\nch dcm4chee\n\n\n\n\n\n\n아래의 내용을 복사하여 dcm4chee 폴더에 docker-compose.yml로 저장합니다.\n매뉴얼에는 version이 있지만 불필요한 메세지만 생성되므로 삭제하였습니다.\n\n\n\n\ndocker-compose.yml\n\nservices:\n  ldap:\n    image: dcm4che/slapd-dcm4chee:2.6.7-33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"389:389\"\n    environment:\n      STORAGE_DIR: /storage/fs1\n    volumes:\n      - /var/local/dcm4chee-arc/ldap:/var/lib/openldap/openldap-data\n      - /var/local/dcm4chee-arc/slapd.d:/etc/openldap/slapd.d\n  db:\n    image: dcm4che/postgres-dcm4chee:17.1-33\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n     - \"5432:5432\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/db:/var/lib/postgresql/data\n  arc:\n    image: dcm4che/dcm4chee-arc-psql:5.33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"8080:8080\"\n      - \"8443:8443\"\n      - \"9990:9990\"\n      - \"9993:9993\"\n      - \"11112:11112\"\n      - \"2762:2762\"\n      - \"2575:2575\"\n      - \"12575:12575\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n      WILDFLY_CHOWN: /storage\n      WILDFLY_WAIT_FOR: ldap:389 db:5432\n    depends_on:\n      - ldap\n      - db\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/wildfly:/opt/wildfly/standalone\n      - /var/local/dcm4chee-arc/storage:/storage\n\n\n\n\n\n\n매뉴얼에서는 docker group에 user를 등록하여 문제가 없으나, 저자는 그러지 않았기 때문에 sudo를 하지 않으면 권한문제로 오류가 발생하므로 매뉴얼과 달리 아래와 같이 sudo로 설치해야 합니다.\n\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee up -d\n\n\n\n\n\nhttp://localhost:8080/dcm4chee-arc/ui2\nor\nhttps://localhost:8443/dcm4chee-arc/ui2",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/dcm4chee.html#wsl2-ubuntu에서의-설치",
    "href": "posts/tools/dcm4chee.html#wsl2-ubuntu에서의-설치",
    "title": "DCM4chee",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host\n\n\n\n\ndocker compose랑 달라서 -이 있는 형태를 설치해야 합니다.\n\n\n\n\nbash\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n\n\n\n\nslapd-dcm4chee, postgres-dcm4chee, dcm4chee-arc 매뉴얼 uid, gid가 999를 넘거나 이미 존재하고 있어, 옵션에 해당하는 이부분을 굳이 변경하여 문제를 일으킬 가능성을 고려하여 설정하지 않고 skip 하였습니다.\nsudo -i 명령으로 프롬프트가 #로 바뀔 수 있음을 주의해야 합니다.\n\n\n\n\nbash\n\n$ sudo -i\ngroupadd -r slapd-dcm4chee --gid=1021 && useradd -r -g slapd-dcm4chee --uid=1021 slapd-dcm4chee\ngroupadd -r postgres-dcm4chee --gid=999 && useradd -r -g postgres-dcm4chee --uid=999 postgres-dcm4chee\ngroupadd -r dcm4chee-arc --gid=1023 && useradd -r -g dcm4chee-arc --uid=1023 dcm4chee-arc\nexit\n\n\n\n\n\n\n\n\nbash\n\nmkdir dcm4chee\nch dcm4chee\n\n\n\n\n\n\n아래의 내용을 복사하여 dcm4chee 폴더에 docker-compose.yml로 저장합니다.\n매뉴얼에는 version이 있지만 불필요한 메세지만 생성되므로 삭제하였습니다.\n\n\n\n\ndocker-compose.yml\n\nservices:\n  ldap:\n    image: dcm4che/slapd-dcm4chee:2.6.7-33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"389:389\"\n    environment:\n      STORAGE_DIR: /storage/fs1\n    volumes:\n      - /var/local/dcm4chee-arc/ldap:/var/lib/openldap/openldap-data\n      - /var/local/dcm4chee-arc/slapd.d:/etc/openldap/slapd.d\n  db:\n    image: dcm4che/postgres-dcm4chee:17.1-33\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n     - \"5432:5432\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/db:/var/lib/postgresql/data\n  arc:\n    image: dcm4che/dcm4chee-arc-psql:5.33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"8080:8080\"\n      - \"8443:8443\"\n      - \"9990:9990\"\n      - \"9993:9993\"\n      - \"11112:11112\"\n      - \"2762:2762\"\n      - \"2575:2575\"\n      - \"12575:12575\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n      WILDFLY_CHOWN: /storage\n      WILDFLY_WAIT_FOR: ldap:389 db:5432\n    depends_on:\n      - ldap\n      - db\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/wildfly:/opt/wildfly/standalone\n      - /var/local/dcm4chee-arc/storage:/storage\n\n\n\n\n\n\n매뉴얼에서는 docker group에 user를 등록하여 문제가 없으나, 저자는 그러지 않았기 때문에 sudo를 하지 않으면 권한문제로 오류가 발생하므로 매뉴얼과 달리 아래와 같이 sudo로 설치해야 합니다.\n\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee up -d\n\n\n\n\n\nhttp://localhost:8080/dcm4chee-arc/ui2\nor\nhttps://localhost:8443/dcm4chee-arc/ui2",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/dcm4chee.html#제거",
    "href": "posts/tools/dcm4chee.html#제거",
    "title": "DCM4chee",
    "section": "제거",
    "text": "제거\n\n1차 제거\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee down --rmi all --volumes --remove-orphans\n\n\n\n\n리소스 제거\n\n\n\nbash\n\nsudo docker system prune -a --volumes",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/PostgreSQL.html",
    "href": "posts/tools/PostgreSQL.html",
    "title": "PostgreSQL",
    "section": "",
    "text": "Berkeley Software Distribution (BSD) license\n\n\n필요성\nOrthanc dicom 저장시 연결하면 속도가 향상되므로 필요\n\n\n설치파일\nhttps://www.enterprisedb.com/downloads/postgres-postgresql-downloads\n\n\n설치방법\n\n프로그램 자체는 default folder에 설치한다.\n그러나 data는 여러가지 목적에 의해서\n\nPC에서는 E:\\17,\n노트북에서는 C:\\17설치하였다.\n\npassworkd는 “postgres”로 진행하고 추후 변경하기로 했다.\npath 설정은 manual로 해야 한다.\n\n\n\nOrthanc의 dicom 저장소로 설정하기\n\ndatabase 만들기\n\nPostgreSQL의 정상실행여부는 윈도우 서비스에서 확인할 수 있고, 다양한 command로도 확인할 수 있다.\n\npsql -U postgres\nCREATE USER nmuser WITH PASSWORD 'iloveben';\nCREATE DATABASE orthanc OWNER nmuser;\nGRANT ALL PRIVILEGES ON DATABASE orthanc TO nmuser;",
    "crumbs": [
      "Tools",
      "PostgreSQL"
    ]
  },
  {
    "objectID": "posts/tools/docker.html",
    "href": "posts/tools/docker.html",
    "title": "Docker",
    "section": "",
    "text": "공식도커사이트(https://docs.docker.com/engine/install/ubuntu/) 내용을 참고하여 진행함",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#사전-준비",
    "href": "posts/tools/docker.html#사전-준비",
    "title": "Docker",
    "section": "사전 준비",
    "text": "사전 준비\n\n방화벽 제한 사항\n어려워서 패스\n\n⚠️ 주의\nufw 또는 firewalld를 사용하여 방화벽을 관리하는 경우, Docker를 통해 컨테이너 포트를 노출하면 방화벽 규칙을 우회할 수 있습니다. 자세한 내용은 Docker와 ufw 문서를 참고하세요.\nDocker는 iptables-nft 및 iptables-legacy만 지원합니다. nft를 사용하여 생성한 방화벽 규칙은 Docker에서 동작하지 않습니다. 방화벽 규칙을 적용하려면 iptables 또는 ip6tables를 사용해야 하며, DOCKER-USER 체인에 추가해야 합니다. 자세한 내용은 패킷 필터링 및 방화벽 문서를 참고하세요.\n\n\n\n운영체제 요구 사항\nDocker Engine을 설치하려면 다음 중 하나의 64비트 우분투(Ubuntu) 버전이 필요합니다.\n\nUbuntu Oracular 24.10\nUbuntu Noble 24.04 (LTS)\nUbuntu Jammy 22.04 (LTS)\nUbuntu Focal 20.04 (LTS)\n\nDocker Engine은 다음 아키텍처를 지원합니다: x86_64 (amd64), armhf, arm64, s390x, ppc64le (ppc64el)\n\n📌 참고:\nUbuntu 기반 배포판(예: Linux Mint)은 공식적으로 지원되지 않습니다.",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#wsl2ubuntu에서의-설치",
    "href": "posts/tools/docker.html#wsl2ubuntu에서의-설치",
    "title": "Docker",
    "section": "WSL2/Ubuntu에서의 설치",
    "text": "WSL2/Ubuntu에서의 설치\n\n이전 버전 제거\nDocker Engine을 설치하기 전에 충돌을 방지하기 위해 기존의 비공식 Docker 패키지를 제거해야 합니다.\n\n제거해야 하는 패키지 목록:\n\ndocker.io\ndocker-compose\ndocker-compose-v2\ndocker-doc\npodman-docker\ncontainerd\nrunc\n\nfor 명령어를 사용하면 한줄의 명령어로 모두 제거할 수 있습니다.\n\n\n\nBash\n\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n\n\n완벽제거를 위해서는 다음의 문서를 참고하세요. Docker Engine 설치하기 전에 기존 Docker 제거하기\n\n\n\n설치\n여러가지 설치방법이 있으나 여기서는 apt를 이용한 방법으로 진행\n\nSet up Docker’s apt repository.\n\n\n\nBash\n\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\n\nca-certificates: SSL 인증서를 관리하는 패키지로, HTTPS 연결을 신뢰할 수 있도록 설정합니다.\ncurl: 인터넷에서 파일을 다운로드할 수 있도록 하는 명령줄 도구입니다.\ninstall -m 0755 -d /etc/apt/keyrings\n\nm 0755: 디렉토리의 권한을 0755(소유자는 읽기/쓰기/실행 가능, 다른 사용자는 읽기/실행 가능)로 설정\nd: 디렉토리를 생성하는 옵션\n\nf: 요청 실패 시 에러 메시지를 출력\ns: 진행 상태 메시지를 출력하지 않음\nS: -s 옵션과 함께 사용하여 오류 발생 시 메시지를 출력\nL: 리디렉션이 있는 경우 최종 목적지까지 따라감 다운로드된 GPG 키는 /etc/apt/keyrings/docker.asc에 저장됩니다. chmod a+r /etc/apt/keyrings/docker.asc a+r: 모든 사용자(a: all users)에게 읽기(r: read) 권한을 부여 이 설정이 없으면 apt가 GPG 키를 읽을 수 없기 때문에 저장소 검증이 실패할 수 있습니다.\n\n\n\n\nBash\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n\n\ndeb [옵션] 저장소URL 배포판코드네임 [섹션]의 문법을 따릅니다.\ndeb [arch=\\((dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]\n  - deb: 패키지 저장소를 추가하는 명령어\n  - arch=\\)(dpkg –print-architecture): 현재 시스템의 아키텍처를 출력하는 명령어\n\nsigned-by=/etc/apt/keyrings/docker.asc: GPG 키를 사용하여 저장소를 검증\n\nhttps://download.docker.com/linux/ubuntu\n\n도커 공식 저장소 주소\n\n\\((. /etc/os-release && echo \"\\){UBUNTU_CODENAME:-\\(VERSION_CODENAME}\") stable:\n  - /etc/os-release: 환경변수를 load\n  - && echo \"\\){UBUNTU_CODENAME:-$VERSION_CODENAME}“): CODENAME이 없으면 VERSION_CODENAME을 출력\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\ntee: 파일에 입력한 내용을 출력하고 파일에 저장\n/dev/null: 화면 출력을 무시\n\n\n\n\nInstall the Docker packages.\n\n\n\nBash\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n\n\nVerifying by hello-world\n\n\n\nBash\n\nsudo docker run hello-world\n\n\nDocker 설치 파일 구조 (Ubuntu 기준)\n/\n├── usr/\n│   ├── bin/\n│   │   ├── docker               ← Docker CLI 실행 파일\n│   │   ├── docker-compose       ← Docker Compose (별도 설치 시)\n│   │   ├── containerd           ← 컨테이너 런타임\n│   │   └── runc                 ← 컨테이너 실행기\n│   └── share/\n│       └── docker-engine/       ← (있을 경우) 문서, 기본 설정 등\n│\n├── etc/\n│   └── docker/\n│       └── daemon.json          ← Docker 데몬 설정 파일\n│\n├── var/\n│   ├── lib/\n│   │   └── docker/              ← 이미지, 컨테이너, 볼륨 등 저장소\n│   └── run/\n│       └── docker.sock          ← Docker 데몬 통신용 소켓 파일\n│\n├── lib/\n│   └── systemd/\n│       └── system/\n│           └── docker.service   ← systemd 서비스 유닛 파일\n│\n├── etc/\n│   └── systemd/\n│       └── system/\n│           └── docker.service.d/ ← 사용자 정의 systemd 설정 디렉터리\n│\n└── home/\n    └── 사용자명/\n        └── .docker/             ← 사용자 설정, 인증 토큰 등\n\n\n\ndocker-compose\nDocker Compose는 다중 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구입니다. 이 도구를 활용하면 개발 및 배포 과정을 간소화하고 효율적으로 관리할 수 있습니다.\nCompose를 사용하면 하나의 이해하기 쉬운 YAML 구성 파일 내에서 서비스, 네트워크, 볼륨 등을 포함한 전체 애플리케이션 스택을 손쉽게 관리할 수 있습니다. 단 한 개의 명령어로 구성 파일에 명시된 모든 서비스를 생성하고 실행할 수 있다는 점이 큰 장점입니다.\nDocker Compose는 프로덕션, 스테이징, 개발, 테스트 환경은 물론 CI 워크플로우 등 다양한 환경에서 활용될 수 있습니다. 또한, 전체 애플리케이션의 라이프사이클을 관리하기 위한 명령어들을 제공하여,\n서비스 시작, 중지, 재구축 실행 중인 서비스의 상태 확인 실행 중인 서비스의 로그 출력 스트리밍 서비스에 대한 일회성 명령 실행 등의 작업을 손쉽게 수행할 수 있습니다.\n\n설치\n\n\n\nBash\n\nsudo apt-get install docker-compose\n\n\n\n\n\nBash\n\ndocker-compose --version\n\n\n\n\n프로젝트 만들기\n/home/user/docker-compose-test 디렉토리를 생성하고, 해당 디렉토리로 이동합니다.\n\n\ndocker-compose.yml 파일 작성\n\n\n\ndocker-compose.yml\n\nversion: '3'\n\nservices:\n  portainer:\n    image: portainer/portainer-ce:latest\n    container_name: portainer\n    restart: always\n    ports:\n      - \"8000:8000\"  # Portainer Agent 통신용\n      - \"9000:9000\"  # Portainer 웹 UI 접속용 (http://localhost:9000)\n      - \"9443:9443\"  # HTTPS 접속용\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer_data:/data\n\nvolumes:\n  portainer_data:\n\n\n\n\n실행\n\n\n\nBash\n\ndocker compose up -d",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html",
    "href": "posts/tools/Conquest.html",
    "title": "Conquest",
    "section": "",
    "text": "개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#구축-필요성",
    "href": "posts/tools/Conquest.html#구축-필요성",
    "title": "Conquest",
    "section": "",
    "text": "개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#window-운영체제에서의-설치",
    "href": "posts/tools/Conquest.html#window-운영체제에서의-설치",
    "title": "Conquest",
    "section": "Window 운영체제에서의 설치",
    "text": "Window 운영체제에서의 설치\n\n설치파일\n최신 설치파일은 공식사이트가 아닌 Cnquest User Forum에 공개된 2024년 9월 25일 release된 버전 1.5.0e (dicomserver-1.5.0e.zip, https://forum.iq-image.com/forum/index.php?thread/50654-conquest-1-5-0e-released/)가 최신이다.\n\n\n설치방법\n설치방법은 원하는 폴더에서 설치파일의 압축을 풀면된다. 업그레이드시에는 매뉴얼에 따르면 다음의 지시를 따르면 된다. - 기본적으로 exe 및 dll 파일을 교체하면 업데이트 가능하지만, - 일부 설정 파일(dicom.sql, dgatesop.lst, dicom.ini)을 조정할 경우 데이터베이스를 다시 생성해야 할 수도 있습니다. - 서버는 반드시 업데이트 전에 중지해야 하며, 서비스로 실행 중이면 제어판에서 중지 또는 서비스 해제가 필요합니다. - 데이터베이스 재생성이 필요한 경우 매우 오랜 시간이 걸릴 수 있으므로 주의해야 합니다. - 기존 데이터를 유지하려면 dicom.sql을 백업 후 복원하는 것이 좋습니다. - 저자의 경우는 data폴더, acrnema.map, dicom.ini 파일을 제외하고 삭제한 뒤 설치압축파일을 풀면 데이터와 설정이 유지된 체로 업그레이드 하고 database reganeration을 하였다.\n\n\n활용 현황\n이 서버프로그램으로 저자는 NMDose, NMIQ, NMFullData, NMTEMPSERVER, ZettaPACS를 구축하여 선량분석시스템, 영상품질자동화, clinical PACS모사, 임시서버, clinical PACS 모사의 목적으로 사용하고 있다.\n\n\nLua script\n쿼리를 정교하게 할 수 있다.\n\n\n저장파일의 이름을 지정하는 방식\n%id_%studydate%modality_%series_%sopuid.dcm",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#wsl2-ununtu에서의-설치",
    "href": "posts/tools/Conquest.html#wsl2-ununtu에서의-설치",
    "title": "Conquest",
    "section": "WSL2 Ununtu에서의 설치",
    "text": "WSL2 Ununtu에서의 설치\n\n준비\n\n\n\nbash\n\nsudo apt install build-essential g++ make apache2 php libapache2-mod-php php-sqlite3 unzip p7zip-full lua5.1 liblua5.1-0-dev lua-socket luarocks liblua5.1-0\n\n\n\n\n\nbash\n\nsudo luarocks install luafilesystem\n\n\n\n\n\nbash\n\nsudo a2enmod cgi\nsudo a2enmod rewrite\nsudo sed -i 's/AllowOverride None/AllowOverride All/g' /etc/apache2/apache2.conf\nsudo sed -i 's/memory_limit = 128M/memory_limit = 512M/g' /etc/php/*/apache2/php.ini\nsudo sed -i 's/upload_max_filesize = 2M/upload_max_filesize = 250M/g' /etc/php/*/apache2/php.ini\nsudo sed -i 's/post_max_size = 8M/post_max_size = 250M/g' /etc/php/*/apache2/php.ini\nsudo systemctl restart apache2\n\n\n\n\n설치파일 다운로드\n\n\n\nbash\n\nwget http://natura-ingenium.nl/dicomserver/dicomserver150e.zip\nmkdir conquest\ncd conquest\nunzip ../dicomserver150e.zip\nrm ../dicomserver150e.zip\n\n\n\n\n컴파일\n\n\n\nbash\n\nchmod 777 maklinux\n./maklinux\n\n\n\nchoose option 3 or 5 SqLite or SqlLite precompiled\nsay ‘y’ to ‘Regenerate the database’ Deletes previous database contents\nsay ‘y’ to ‘Install as service’ Shows status hit ‘q’ to return\n\n비록 아래의 메세지가 나오더라도 정상임\nFailed to stop conquest.service: Unit conquest.service not loaded.\n\n\n\n\n브라우저로 접속\n\nhttp://localhost/app/newweb/ 또는 http://localhost/app/ohif 주소로 접속\n\n\n\nsystemd 설정\n\ndaemon으로 설정되어 있으므로 systemctl로 관리할 수 있다.\n만약에 설정파일을 변경한 후 재시작을 할려면 아래와 같이 한다.\n\n\n\n\nbash\n\nsudo systemctl restart conquest\n\n\n\n정상작동이 되지 않는다고 생각되면 dgate가 아래의 명령으로 실행되고 있는지 확인해 본다.\n\n\n\n\nbash\n\nsystemctl status conquest",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Slicer.html",
    "href": "posts/tools/Slicer.html",
    "title": "Slicer",
    "section": "",
    "text": "구축 필요성\n개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.\n\n\nSlicer",
    "crumbs": [
      "Tools",
      "Slicer"
    ]
  },
  {
    "objectID": "posts/tools/portainder.html",
    "href": "posts/tools/portainder.html",
    "title": "Docker",
    "section": "",
    "text": "공식도커사이트(https://docs.docker.com/engine/install/ubuntu/) 내용을 참고하여 진행함"
  },
  {
    "objectID": "posts/tools/portainder.html#사전-준비",
    "href": "posts/tools/portainder.html#사전-준비",
    "title": "Docker",
    "section": "사전 준비",
    "text": "사전 준비\n\n방화벽 제한 사항\n어려워서 패스\n\n⚠️ 주의\nufw 또는 firewalld를 사용하여 방화벽을 관리하는 경우, Docker를 통해 컨테이너 포트를 노출하면 방화벽 규칙을 우회할 수 있습니다. 자세한 내용은 Docker와 ufw 문서를 참고하세요.\nDocker는 iptables-nft 및 iptables-legacy만 지원합니다. nft를 사용하여 생성한 방화벽 규칙은 Docker에서 동작하지 않습니다. 방화벽 규칙을 적용하려면 iptables 또는 ip6tables를 사용해야 하며, DOCKER-USER 체인에 추가해야 합니다. 자세한 내용은 패킷 필터링 및 방화벽 문서를 참고하세요.\n\n\n\n운영체제 요구 사항\nDocker Engine을 설치하려면 다음 중 하나의 64비트 우분투(Ubuntu) 버전이 필요합니다.\n\nUbuntu Oracular 24.10\nUbuntu Noble 24.04 (LTS)\nUbuntu Jammy 22.04 (LTS)\nUbuntu Focal 20.04 (LTS)\n\nDocker Engine은 다음 아키텍처를 지원합니다: x86_64 (amd64), armhf, arm64, s390x, ppc64le (ppc64el)\n\n📌 참고:\nUbuntu 기반 배포판(예: Linux Mint)은 공식적으로 지원되지 않습니다."
  },
  {
    "objectID": "posts/tools/portainder.html#이전-버전-제거",
    "href": "posts/tools/portainder.html#이전-버전-제거",
    "title": "Docker",
    "section": "이전 버전 제거",
    "text": "이전 버전 제거\nDocker Engine을 설치하기 전에 충돌을 방지하기 위해 기존의 비공식 Docker 패키지를 제거해야 합니다.\n\n제거해야 하는 패키지 목록:\n\ndocker.io\ndocker-compose\ndocker-compose-v2\ndocker-doc\npodman-docker\ncontainerd\nrunc\n\nfor 명령어를 사용하면 한줄의 명령어로 모두 제거할 수 있습니다.\n\n\n\nBash\n\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n\n\n완벽제거를 위해서는 다음의 문서를 참고하세요. Docker Engine 설치하기 전에 기존 Docker 제거하기"
  },
  {
    "objectID": "posts/tools/portainder.html#설치",
    "href": "posts/tools/portainder.html#설치",
    "title": "Docker",
    "section": "설치",
    "text": "설치\n여러가지 설치방법이 있으나 여기서는 apt를 이용한 방법으로 진행\n\nSet up Docker’s apt repository.\n\n\n\nBash\n\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\n\nca-certificates: SSL 인증서를 관리하는 패키지로, HTTPS 연결을 신뢰할 수 있도록 설정합니다.\ncurl: 인터넷에서 파일을 다운로드할 수 있도록 하는 명령줄 도구입니다.\ninstall -m 0755 -d /etc/apt/keyrings\n\nm 0755: 디렉토리의 권한을 0755(소유자는 읽기/쓰기/실행 가능, 다른 사용자는 읽기/실행 가능)로 설정\nd: 디렉토리를 생성하는 옵션\n\nf: 요청 실패 시 에러 메시지를 출력\ns: 진행 상태 메시지를 출력하지 않음\nS: -s 옵션과 함께 사용하여 오류 발생 시 메시지를 출력\nL: 리디렉션이 있는 경우 최종 목적지까지 따라감 다운로드된 GPG 키는 /etc/apt/keyrings/docker.asc에 저장됩니다. chmod a+r /etc/apt/keyrings/docker.asc a+r: 모든 사용자(a: all users)에게 읽기(r: read) 권한을 부여 이 설정이 없으면 apt가 GPG 키를 읽을 수 없기 때문에 저장소 검증이 실패할 수 있습니다.\n\n\n\n\nBash\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n\n\ndeb [옵션] 저장소URL 배포판코드네임 [섹션]의 문법을 따릅니다.\ndeb [arch=\\((dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]\n  - deb: 패키지 저장소를 추가하는 명령어\n  - arch=\\)(dpkg –print-architecture): 현재 시스템의 아키텍처를 출력하는 명령어\n\nsigned-by=/etc/apt/keyrings/docker.asc: GPG 키를 사용하여 저장소를 검증\n\nhttps://download.docker.com/linux/ubuntu\n\n도커 공식 저장소 주소\n\n\\((. /etc/os-release && echo \"\\){UBUNTU_CODENAME:-\\(VERSION_CODENAME}\") stable:\n  - /etc/os-release: 환경변수를 load\n  - && echo \"\\){UBUNTU_CODENAME:-$VERSION_CODENAME}“): CODENAME이 없으면 VERSION_CODENAME을 출력\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\ntee: 파일에 입력한 내용을 출력하고 파일에 저장\n/dev/null: 화면 출력을 무시\n\n\n\n\nInstall the Docker packages.\n\n\n\nBash\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n\n\nVerifying by hello-world\n\n\n\nBash\n\nsudo docker run hello-world"
  },
  {
    "objectID": "posts/tools/portainder.html#portainer-설치",
    "href": "posts/tools/portainder.html#portainer-설치",
    "title": "Docker",
    "section": "Portainer 설치",
    "text": "Portainer 설치\n\nPortainer 개념\nPortainer는 Docker 및 Kubernetes 컨테이너 관리를 위한 웹 기반 UI 도구입니다.\nCLI(Command Line Interface) 없이도 컨테이너, 이미지, 네트워크, 볼륨 등을 손쉽게 관리할 수 있습니다.\n\n🔹 주요 기능\n\n컨테이너 관리: 실행, 중지, 삭제, 로그 확인\n이미지 관리: 이미지 다운로드, 삭제, 태그 지정\n네트워크 및 볼륨 관리: 컨테이너 간 네트워크 설정 및 데이터 볼륨 관리\n사용자 및 액세스 제어: 여러 사용자와 권한 설정 가능\nSwarm 및 Kubernetes 지원: Docker Swarm과 Kubernetes 클러스터 관리 가능\n\n\n\n\n\nPortainer 설치 방법\nPortainer는 Docker 컨테이너로 실행되므로, Docker가 설치되어 있어야 합니다.\n\n볼륨 생성\nPortainer의 설정 및 데이터는 볼륨(volume)에 저장됩니다.\n\n\n\nBash\n\ndocker volume create portainer_data\n\n\n\n\nPortainer 컨테이너 실행**\n이는 원격으로 이미지다운로드를 포함한다.\n\n\n\nBash\n\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n\n\n\n-d: 백그라운드에서 컨테이너 실행\n-p 8000:8000 -p 9000:9000: 호스트 포트와 컨테이너 포트 매핑\n--name=portainer: 컨테이너 이름 지정\n--restart=always: 컨테이너가 종료되면 자동으로 재시작\n-v /var/run/docker.sock:/var/run/docker.sock: 호스트의 Docker 소켓을 컨테이너 내부로 연결\n-v portainer_data:/data: Portainer 설정 및 데이터를 저장할 볼륨 연결\nportainer/portainer-ce: Portainer 컨테이너 이미지\n\n\n\n실행중인 container 확인\n\n\n\nBash\n\ndocker ps\n\n\n\n\nPortainer 제거\n\n\n\nBash\n\ndocker stop portainer\ndocker rm -f portainer\n\n\n\n\n로그인 id & password\nben benjamin060318\n\n\n\ndocker-compose\nDocker Compose는 다중 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구입니다. 이 도구를 활용하면 개발 및 배포 과정을 간소화하고 효율적으로 관리할 수 있습니다.\nCompose를 사용하면 하나의 이해하기 쉬운 YAML 구성 파일 내에서 서비스, 네트워크, 볼륨 등을 포함한 전체 애플리케이션 스택을 손쉽게 관리할 수 있습니다. 단 한 개의 명령어로 구성 파일에 명시된 모든 서비스를 생성하고 실행할 수 있다는 점이 큰 장점입니다.\nDocker Compose는 프로덕션, 스테이징, 개발, 테스트 환경은 물론 CI 워크플로우 등 다양한 환경에서 활용될 수 있습니다. 또한, 전체 애플리케이션의 라이프사이클을 관리하기 위한 명령어들을 제공하여,\n서비스 시작, 중지, 재구축 실행 중인 서비스의 상태 확인 실행 중인 서비스의 로그 출력 스트리밍 서비스에 대한 일회성 명령 실행 등의 작업을 손쉽게 수행할 수 있습니다.\n\n설치\n\n\n\nBash\n\nsudo apt-get install docker-compose\n\n\n\n\n\nBash\n\ndocker-compose --version\n\n\n\n\n프로젝트 만들기\n/home/user/docker-compose-test 디렉토리를 생성하고, 해당 디렉토리로 이동합니다.\n\n\ndocker-compose.yml 파일 작성\n\n\n\ndocker-compose.yml\n\nversion: '3'\n\nservices:\n  portainer:\n    image: portainer/portainer-ce:latest\n    container_name: portainer\n    restart: always\n    ports:\n      - \"8000:8000\"  # Portainer Agent 통신용\n      - \"9000:9000\"  # Portainer 웹 UI 접속용 (http://localhost:9000)\n      - \"9443:9443\"  # HTTPS 접속용\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer_data:/data\n\nvolumes:\n  portainer_data:\n\n\n\n\n실행\n\n\n\nBash\n\ndocker compose up -d"
  },
  {
    "objectID": "posts/tools/chocolatey.html",
    "href": "posts/tools/chocolatey.html",
    "title": "Chocolatey",
    "section": "",
    "text": "DCMTK 때문에 설치\n\n\n\n\nWin+X+A로 관리자권한 PowerShell을 엽니다.\n아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n\n\n\n관리자:Windows PowerShell\n\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\n\n\n이전 버전 설치 시 상황이 기억나지 않으므로 기존 설치폴더를 제거하고 설치하여 성공함\n\nCommand Prompt를 관리자권한으로 가장 빠르게 여는 방법은 Win+X입니다.\n아래의 명령으로 설치된 Linux 배포판을 확인합니다.\n\n\n\n\n관리자권한 Command Prompt\n\n wsl --list --verbose\n\n\n또는\n\n\n\n관리자권한 Command Prompt\n\n wsl -l -v\n\n\n\n\n\n아래와 같이 Linux 배포판의 등록을 취소하고 제거합니다.\n\n\n\n관리자권한 Command Prompt\n\nwsl --unregister Ubuntu-24.04\n\n\n\n이때 완료라는 메세지가 출력됩니다.\n이렇게 하면 우분투가 사용하는 가상 디스크(ext4.vhdx)파일도 자동으로 삭제되어 편리하며 혹시 오류가 있어 삭제되지 않을 수 있으므로 확인하는 것이 바람직합니다.\n\nC:\\Users\\&lt;사용자이름&gt;\\AppData\\Local\\Packages\\ 에서 Canonical* 폴더 삭제\nC:\\Program Files\\WindowsApps 내 Canonical* 폴더 삭제 (권한 필요)\n\n후자는 권한이 필요하여, C:\\Program Files\\WindowsApps 폴더의 소유자를 변경하는 것보다 아래와 같이 Command Prompt를 관리자권한으로 열어서 del 명령으로 삭제하는 것이 훨씬 간편하다.\n\n시작메뉴를 누르고 검색에 cmd를 입력하고, 마우스 오른쪽 버튼을 눌러 관리자권한으로 실행한다.\n\n\n\n\n\nCommand Prompt\n\ndel /f /q \"C:\\경로\\파일이름\"\n\n\n\n\n\n\n시작메뉴를 누르고 설정을 클릭하고, 앱을 클릭하여 Ubuntu를 검색하여 제거합니다.\n\n\n\n\n\n\n\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\n\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#필요성",
    "href": "posts/tools/chocolatey.html#필요성",
    "title": "Chocolatey",
    "section": "",
    "text": "DCMTK 때문에 설치\n\n\n\n\nWin+X+A로 관리자권한 PowerShell을 엽니다.\n아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n\n\n\n관리자:Windows PowerShell\n\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\n\n\n이전 버전 설치 시 상황이 기억나지 않으므로 기존 설치폴더를 제거하고 설치하여 성공함\n\nCommand Prompt를 관리자권한으로 가장 빠르게 여는 방법은 Win+X입니다.\n아래의 명령으로 설치된 Linux 배포판을 확인합니다.\n\n\n\n\n관리자권한 Command Prompt\n\n wsl --list --verbose\n\n\n또는\n\n\n\n관리자권한 Command Prompt\n\n wsl -l -v\n\n\n\n\n\n아래와 같이 Linux 배포판의 등록을 취소하고 제거합니다.\n\n\n\n관리자권한 Command Prompt\n\nwsl --unregister Ubuntu-24.04\n\n\n\n이때 완료라는 메세지가 출력됩니다.\n이렇게 하면 우분투가 사용하는 가상 디스크(ext4.vhdx)파일도 자동으로 삭제되어 편리하며 혹시 오류가 있어 삭제되지 않을 수 있으므로 확인하는 것이 바람직합니다.\n\nC:\\Users\\&lt;사용자이름&gt;\\AppData\\Local\\Packages\\ 에서 Canonical* 폴더 삭제\nC:\\Program Files\\WindowsApps 내 Canonical* 폴더 삭제 (권한 필요)\n\n후자는 권한이 필요하여, C:\\Program Files\\WindowsApps 폴더의 소유자를 변경하는 것보다 아래와 같이 Command Prompt를 관리자권한으로 열어서 del 명령으로 삭제하는 것이 훨씬 간편하다.\n\n시작메뉴를 누르고 검색에 cmd를 입력하고, 마우스 오른쪽 버튼을 눌러 관리자권한으로 실행한다.\n\n\n\n\n\nCommand Prompt\n\ndel /f /q \"C:\\경로\\파일이름\"\n\n\n\n\n\n\n시작메뉴를 누르고 설정을 클릭하고, 앱을 클릭하여 Ubuntu를 검색하여 제거합니다.\n\n\n\n\n\n\n\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\n\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#wsl2-설치",
    "href": "posts/tools/chocolatey.html#wsl2-설치",
    "title": "Chocolatey",
    "section": "WSL2 설치",
    "text": "WSL2 설치\n\nWindow edition 및 버전확인\n윈도우 10 HOME 버전의 경우 ARM64 시스템의 경우 빌드 19041부터 WSL 2를 지원한다.\n\n\n\n\nWSL 설치명령\n이전과는 다르게 아래의 자동화된 명령한 줄로 설치가 됩니다.\n\n\n\nPowerShell\n\nwsl --install\n\n\n이는 wsl 옵션과 가상머신플랫폼을 활성화시키고 최신 리눅스커널까지 upgrade해 줍니다.\n\n\n재부팅\n변경사항을 적용하기 위해서는 시스템을 다시 시작하라는 메세지가 나옵니다.\n\n\n중간점검\n\nWin+X+A로 관리자권한 Command Prompt를 열어서\n\n리눅스커널이 정상작동하는지 아래의 명령어로 확인합니다.\n\n\n\n\n\n관리자: 명령 프롬프트\n\nwsl --version\n\n\nWSL 버전과 커널버전까지 표시되므로 확인할 수 있습니다.",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#우분투설치",
    "href": "posts/tools/chocolatey.html#우분투설치",
    "title": "Chocolatey",
    "section": "우분투설치",
    "text": "우분투설치\n\n관리자권한 Command Prompt에서 다음의 명령을 입력하여 최신 배포판을 설치할 수 있습니다.\n그런데 방화벽이나 회상방침에 따라 인터넷 연결이 제한적인 경우에는 문제가 발생하여 Public WiFi로 전환하면 성공하게 됩니다.\n\n\n\n\n관리자: 명령 프롬프트\n\nwsl --install -d Ubuntu\n\n\n\ndefault Unix user accout\n\n소문자가 바람직하다.\npasswd를 입력하라는 메세지가 나오면, 비밀번호를 입력한다.\n\n\n\n우분투 디렉토리 구조\n\n\n\n/\n├── bin → /usr/bin         # 주요 실행 파일 (ls, cp 등)이 위치한 디렉토리. 기본 명령어 포함.\n├── boot                   # 부팅 관련 파일이 저장됨 (커널, grub 등).\n├── dev                    # 장치 파일(device files)이 위치 (예: /dev/sda, /dev/null 등).\n├── etc                    # 시스템 설정 파일(configuration files)이 저장된 곳.\n├── home                   # 일반 사용자들의 홈 디렉토리 (예: /home/username).\n├── lib → /usr/lib         # 공유 라이브러리(.so 파일)들이 저장된 디렉토리.\n├── lib64 → /usr/lib64     # 64비트 라이브러리들이 저장됨.\n├── media                  # USB, CD-ROM 등의 자동 마운트 지점.\n├── mnt                    # 외부 장치를 수동으로 마운트할 때 사용하는 디렉토리.\n├── opt                    # 서드파티 애플리케이션들이 설치되는 디렉토리 (예: /opt/google).\n├── proc                   # 실행 중인 프로세스 및 커널 정보가 담긴 가상 파일 시스템.\n├── root                   # root(관리자) 사용자의 홈 디렉토리.\n├── run                    # 부팅 후 생성되는 임시 런타임 데이터가 저장됨.\n├── sbin → /usr/sbin       # 시스템 관리 명령어들이 위치 (예: reboot, iptables 등).\n├── srv                    # 웹, FTP 등 서비스를 위한 데이터 저장용 디렉토리.\n├── sys                    # 시스템 하드웨어 및 장치 정보에 접근하는 가상 파일 시스템.\n├── tmp                    # 임시 파일 저장소. 재부팅 시 대부분 삭제됨.\n├── usr                    # 사용자 명령어 및 라이브러리 저장소.\n│   ├── bin                # 대부분의 사용자 명령어들이 위치.\n│   ├── lib                # 라이브러리 파일들.\n│   ├── lib64              # 64비트 전용 라이브러리.\n│   ├── sbin               # 시스템 명령어.\n│   └── share              # 공유 데이터 (man page, 아이콘 등).\n└── var                    # 로그, 캐시, 메일 등 자주 변경되는 파일 저장소.\n    ├── log                # 시스템 로그 파일 저장소.\n    ├── cache              # 애플리케이션 캐시.\n    └── tmp                # 임시 파일 저장소 (보다 긴 기간 유지될 수 있음).\n\n\nFigure 1: Ubuntu의 디렉토리 구조",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#설정",
    "href": "posts/tools/chocolatey.html#설정",
    "title": "Chocolatey",
    "section": "설정",
    "text": "설정\n\n/etc/wsl.conf\nsystemd의 설정을 true로 변경하여 systemd를 사용할 수 있도록 설정합니다.\n\n\n\n/etc/wsl.conf\n\n[boot]\nsystemd=true",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#네트워크",
    "href": "posts/tools/chocolatey.html#네트워크",
    "title": "Chocolatey",
    "section": "네트워크",
    "text": "네트워크\n\n윈도우에서 wsl2 가상 IP 확인하기\n\n\n\ncmd or ps\n\nwsl hostname -i\n\n\n\n127.0.1.1\n그러나 이 결과는 원하는 결과가 아닌 127.0.0.1과 유사하다.\n\n\n\n\nbash\n\nsudo apt-get install net-tools\n\n\n\n\n\nbash\n\nifconfig\n\n\n\neth0의 inet이 원하는 결과이며 윈도우에서 wsl2에 설치된 서버에 접근할 때 사용딥니다. 하지만 부팅 시마다 달라집니다.\n참고로 도커와 사용자정의 도커와 루프도 같이 출력됨.\n\n\n\nwsl2 가상 ip 검증\n\n\n\ncmd\n\nping 172.21.120.237\n\n\n\n방화벽등의 원인으로 막힐 수도 있음\n\n\n\n포트 검증\n\ndicom server에서 열어도 포트가 4242라면\n\n\n\n\ncmd\n\nTest-NetConnection -ComputerName 172.21.120.237 -Port 4242",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/chocolatey.html#이전설치방식",
    "href": "posts/tools/chocolatey.html#이전설치방식",
    "title": "Chocolatey",
    "section": "이전설치방식",
    "text": "이전설치방식\n\nwsl 옵션 활성화\n\nPowershell 관리자권한으로 열어서 아래 명령어를 실행한다.\n\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\nVirtualMachinePlatform 옵션 활성화\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\nLinux 커널 업데이트\n윈도우에 포함된 기본 버전을 업데이트하는 방법도 있다.\n\n\n\nPowerShell\n\nwsl --upgrade\n\n\n아래의 명령을 전후로 사용하면 Kenel의 버전을 비교하여 알 수 있다.\n\n\n\nPowerShell\n\nwsl --status",
    "crumbs": [
      "Tools",
      "Chocolatey"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html",
    "href": "posts/tools/wsl2_ubuntu.html",
    "title": "WSL2/Ubuntu",
    "section": "",
    "text": "개발환경으로써 리눅스가 가장 유리하겠으나, 현단계에서는 WSL2를 대안으로 선택함\n특히, NMIQ의 설치는 도커배포를 계획하고 있어 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#필요성",
    "href": "posts/tools/wsl2_ubuntu.html#필요성",
    "title": "WSL2/Ubuntu",
    "section": "",
    "text": "개발환경으로써 리눅스가 가장 유리하겠으나, 현단계에서는 WSL2를 대안으로 선택함\n특히, NMIQ의 설치는 도커배포를 계획하고 있어 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#wsl2상의-우분투-완전-제거",
    "href": "posts/tools/wsl2_ubuntu.html#wsl2상의-우분투-완전-제거",
    "title": "WSL2/Ubuntu",
    "section": "WSL2상의 우분투 완전 제거",
    "text": "WSL2상의 우분투 완전 제거\n\n우분투버전 확인\n\nCommand Prompt를 관리자권한으로 가장 빠르게 여는 방법은 Win+X입니다.\n아래의 명령으로 설치된 Linux 배포판을 확인합니다.\n\n\n\n\n관리자권한 Command Prompt\n\n wsl --list --verbose\n\n\n또는\n\n\n\n관리자권한 Command Prompt\n\n wsl -l -v\n\n\n\n\n우분투 등록 취소 및 제거\n아래와 같이 Linux 배포판의 등록을 취소하고 제거합니다.\n\n\n\n관리자권한 Command Prompt\n\nwsl --unregister Ubuntu-24.04\n\n\n\n이때 완료라는 메세지가 출력됩니다.\n이렇게 하면 우분투가 사용하는 가상 디스크(ext4.vhdx)파일도 자동으로 삭제되어 편리하며 혹시 오류가 있어 삭제되지 않을 수 있으므로 확인하는 것이 바람직합니다.\n\nC:\\Users\\&lt;사용자이름&gt;\\AppData\\Local\\Packages\\ 에서 Canonical* 폴더 삭제\nC:\\Program Files\\WindowsApps 내 Canonical* 폴더 삭제 (권한 필요)\n\n후자는 권한이 필요하여, C:\\Program Files\\WindowsApps 폴더의 소유자를 변경하는 것보다 아래와 같이 Command Prompt를 관리자권한으로 열어서 del 명령으로 삭제하는 것이 훨씬 간편하다.\n\n시작메뉴를 누르고 검색에 cmd를 입력하고, 마우스 오른쪽 버튼을 눌러 관리자권한으로 실행한다.\n\n\n\n\n\nCommand Prompt\n\ndel /f /q \"C:\\경로\\파일이름\"\n\n\n\n\n윈도우에서 앱제거\n\n시작메뉴를 누르고 설정을 클릭하고, 앱을 클릭하여 Ubuntu를 검색하여 제거합니다.\n\n\n\n재부팅\n\n\nVirtualMachinePlatform 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\nwsl 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\n재부팅",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#wsl2-설치",
    "href": "posts/tools/wsl2_ubuntu.html#wsl2-설치",
    "title": "WSL2/Ubuntu",
    "section": "WSL2 설치",
    "text": "WSL2 설치\n\nWindow edition 및 버전확인\n윈도우 10 HOME 버전의 경우 ARM64 시스템의 경우 빌드 19041부터 WSL 2를 지원한다.\n\n\n\n\nWSL 설치명령\n이전과는 다르게 아래의 자동화된 명령한 줄로 설치가 됩니다.\n\n\n\nPowerShell\n\nwsl --install\n\n\n이는 wsl 옵션과 가상머신플랫폼을 활성화시키고 최신 리눅스커널까지 upgrade해 줍니다.\n\n\n재부팅\n변경사항을 적용하기 위해서는 시스템을 다시 시작하라는 메세지가 나옵니다.\n\n\n중간점검\n\nWin+X+A로 관리자권한 Command Prompt를 열어서\n\n리눅스커널이 정상작동하는지 아래의 명령어로 확인합니다.\n\n\n\n\n\n관리자: 명령 프롬프트\n\nwsl --version\n\n\nWSL 버전과 커널버전까지 표시되므로 확인할 수 있습니다.",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#우분투설치",
    "href": "posts/tools/wsl2_ubuntu.html#우분투설치",
    "title": "WSL2/Ubuntu",
    "section": "우분투설치",
    "text": "우분투설치\n\n관리자권한 Command Prompt에서 다음의 명령을 입력하여 최신 배포판을 설치할 수 있습니다.\n그런데 방화벽이나 회상방침에 따라 인터넷 연결이 제한적인 경우에는 문제가 발생하여 Public WiFi로 전환하면 성공하게 됩니다.\n\n\n원하는 배포판 설치\n\n\n\n관리자: 명령 프롬프트\n\nwsl --install -d Ubuntu\n\n\n\n\ndefault Unix user accout\n\n소문자가 바람직하다.\npasswd를 입력하라는 메세지가 나오면, 비밀번호를 입력한다.\n\n\n\n우분투 디렉토리 구조\n\n\n\n/\n├── bin → /usr/bin         # 주요 실행 파일 (ls, cp 등)이 위치한 디렉토리. 기본 명령어 포함.\n├── boot                   # 부팅 관련 파일이 저장됨 (커널, grub 등).\n├── dev                    # 장치 파일(device files)이 위치 (예: /dev/sda, /dev/null 등).\n├── etc                    # 시스템 설정 파일(configuration files)이 저장된 곳.\n├── home                   # 일반 사용자들의 홈 디렉토리 (예: /home/username).\n├── lib → /usr/lib         # 공유 라이브러리(.so 파일)들이 저장된 디렉토리.\n├── lib64 → /usr/lib64     # 64비트 라이브러리들이 저장됨.\n├── media                  # USB, CD-ROM 등의 자동 마운트 지점.\n├── mnt                    # 외부 장치를 수동으로 마운트할 때 사용하는 디렉토리.\n├── opt                    # 서드파티 애플리케이션들이 설치되는 디렉토리 (예: /opt/google).\n├── proc                   # 실행 중인 프로세스 및 커널 정보가 담긴 가상 파일 시스템.\n├── root                   # root(관리자) 사용자의 홈 디렉토리.\n├── run                    # 부팅 후 생성되는 임시 런타임 데이터가 저장됨.\n├── sbin → /usr/sbin       # 시스템 관리 명령어들이 위치 (예: reboot, iptables 등).\n├── srv                    # 웹, FTP 등 서비스를 위한 데이터 저장용 디렉토리.\n├── sys                    # 시스템 하드웨어 및 장치 정보에 접근하는 가상 파일 시스템.\n├── tmp                    # 임시 파일 저장소. 재부팅 시 대부분 삭제됨.\n├── usr                    # 사용자 명령어 및 라이브러리 저장소.\n│   ├── bin                # 대부분의 사용자 명령어들이 위치.\n│   ├── lib                # 라이브러리 파일들.\n│   ├── lib64              # 64비트 전용 라이브러리.\n│   ├── sbin               # 시스템 명령어.\n│   └── share              # 공유 데이터 (man page, 아이콘 등).\n└── var                    # 로그, 캐시, 메일 등 자주 변경되는 파일 저장소.\n    ├── log                # 시스템 로그 파일 저장소.\n    ├── cache              # 애플리케이션 캐시.\n    └── tmp                # 임시 파일 저장소 (보다 긴 기간 유지될 수 있음).\n\n\nFigure 1: Ubuntu의 디렉토리 구조",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#설정",
    "href": "posts/tools/wsl2_ubuntu.html#설정",
    "title": "WSL2/Ubuntu",
    "section": "설정",
    "text": "설정\n\nsystemd 설정\n\n/etc/wsl.conf\nsystemd의 설정을 true로 변경하여 systemd를 사용할 수 있도록 설정합니다.\n\n\n\n\n/etc/wsl.conf\n\n[boot]\nsystemd=true\n\n\n\n\nWindow to WSL2 네트워크\n\n윈도우에서 wsl2 가상 IP 확인하기\n\n\n\ncmd or ps\n\nwsl hostname -i\n\n\n\n127.0.1.1\n그러나 이 결과는 원하는 결과가 아닌 127.0.0.1과 유사하다.\n\n\n\n\nbash\n\nsudo apt-get install net-tools\n\n\n\n\n\nbash\n\nifconfig\n\n\n\neth0의 inet이 원하는 결과이며 윈도우에서 wsl2에 설치된 서버에 접근할 때 사용딥니다. 하지만 부팅 시마다 달라집니다.\n참고로 도커와 사용자정의 도커와 루프도 같이 출력됨.\n\n\n\nwsl2 가상 ip 검증\n\n\n\ncmd\n\nping 172.21.120.237\n\n\n\n방화벽등의 원인으로 막힐 수도 있음\n\n\n\n포트 검증\n\ndicom server에서 열어도 포트가 4242라면\n\n\n\n\n관리자: Windows PowerShell\n\nTest-NetConnection -ComputerName 172.21.120.237 -Port 4242\n\n\n\n\n\nWSL2 to Window 네트워크\n\n윈도우의 IP 확인\n\n\n\ncmd\n\nipconfig\n\n\n\n어탭터의 설정과 어떤 어댑터를 선택하는지에 따라 달라지는 것 같음.\n노트북과 PC 공통적으로 아래의 아이피를 선택할 수 있으나 이는 윈도우용 가상 아이피임.\n172.17.130.79\n노트북에서 성공했을 때는 무선랜의 아이피를 선택했었음.\n그러나 PC에서는 유선랜의 아이피를 선택했을 때 일단 실패 했음\n\n\n\n포트확인\n\n\n\nbash\n\nnc -vz 172.17.130.79 5678",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#네트워크",
    "href": "posts/tools/wsl2_ubuntu.html#네트워크",
    "title": "WSL2/Ubuntu",
    "section": "네트워크",
    "text": "네트워크\n\n윈도우에서 wsl2 가상 IP 확인하기\n\n\n\ncmd or ps\n\nwsl hostname -i\n\n\n\n127.0.1.1\n그러나 이 결과는 원하는 결과가 아닌 127.0.0.1과 유사하다.\n\n\n\n\nbash\n\nsudo apt-get install net-tools\n\n\n\n\n\nbash\n\nifconfig\n\n\n\neth0의 inet이 원하는 결과이며 윈도우에서 wsl2에 설치된 서버에 접근할 때 사용딥니다. 하지만 부팅 시마다 달라집니다.\n참고로 도커와 사용자정의 도커와 루프도 같이 출력됨.\n\n\n\nwsl2 가상 ip 검증\n\n\n\ncmd\n\nping 172.21.120.237\n\n\n\n방화벽등의 원인으로 막힐 수도 있음\n\n\n\n포트 검증\n\ndicom server에서 열어도 포트가 4242라면\n\n\n\n\ncmd\n\nTest-NetConnection -ComputerName 172.21.120.237 -Port 4242\n\n\n\n\n윈도우의 IP 확인\n\n\n\ncmd\n\nipconfig\n\n\n\n172.17.130.79\n\n\n포트확인\n\n\n\nbash\n\nnc -vz 172.17.130.79 5678",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/dcmtk.html",
    "href": "posts/tools/dcmtk.html",
    "title": "DCMTK",
    "section": "",
    "text": "DCMTK는 윈도우에서 설치할 수 있는 방법이 여러가지가 있지만 Chocolatey를 설치하여 진행하였다.\nChocolatey는 윈도우에서 패키지 관리자를 제공하는 오픈소스 프로젝트로, DCMTK를 포함한 다양한 소프트웨어를 쉽게 설치하고 관리할 수 있습니다.\n\n\n\n\nChocolatey를 설치하기 위해서는 관리자 권한으로 PowerShell을 실행해야 합니다.\nPowerShell을 관리자 권한으로 실행하는 방법은 시작 메뉴에서 “PowerShell”을 검색한 후, 마우스 오른쪽 버튼을 클릭하고 “관리자 권한으로 실행”을 선택합니다.\nPowerShell이 열리면 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n\n\n\n관리자: Window PowerShell\n\nchoco install dcmtk\n\n\n\n설치 메세지가 복잡하여 A로 모두 동의하고 설치를 진행하였다.\n설치가 완료되면 아래의 명령어를 입력하여 DCMTK가 정상적으로 설치되었는지 확인합니다.\n\n\n\n\n관리자: Window PowerShell\n\ndcmdump --version\n\n\n\n\n\n관리자: Windows PowerShell\n\nTest-NetConnection -ComputerName 172.21.120.237 -Port 4242\n\n\n\n\n\ncmd\n\nechoscu -v -aec ORTHANC -aet DCMTK 172.21.120.237 4242",
    "crumbs": [
      "Tools",
      "DCMTK"
    ]
  },
  {
    "objectID": "posts/tools/dcmtk.html#window-환경에서의-설치",
    "href": "posts/tools/dcmtk.html#window-환경에서의-설치",
    "title": "DCMTK",
    "section": "",
    "text": "DCMTK는 윈도우에서 설치할 수 있는 방법이 여러가지가 있지만 Chocolatey를 설치하여 진행하였다.\nChocolatey는 윈도우에서 패키지 관리자를 제공하는 오픈소스 프로젝트로, DCMTK를 포함한 다양한 소프트웨어를 쉽게 설치하고 관리할 수 있습니다.\n\n\n\n\nChocolatey를 설치하기 위해서는 관리자 권한으로 PowerShell을 실행해야 합니다.\nPowerShell을 관리자 권한으로 실행하는 방법은 시작 메뉴에서 “PowerShell”을 검색한 후, 마우스 오른쪽 버튼을 클릭하고 “관리자 권한으로 실행”을 선택합니다.\nPowerShell이 열리면 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n\n\n\n관리자: Window PowerShell\n\nchoco install dcmtk\n\n\n\n설치 메세지가 복잡하여 A로 모두 동의하고 설치를 진행하였다.\n설치가 완료되면 아래의 명령어를 입력하여 DCMTK가 정상적으로 설치되었는지 확인합니다.\n\n\n\n\n관리자: Window PowerShell\n\ndcmdump --version\n\n\n\n\n\n관리자: Windows PowerShell\n\nTest-NetConnection -ComputerName 172.21.120.237 -Port 4242\n\n\n\n\n\ncmd\n\nechoscu -v -aec ORTHANC -aet DCMTK 172.21.120.237 4242",
    "crumbs": [
      "Tools",
      "DCMTK"
    ]
  },
  {
    "objectID": "posts/tools/SDKMAN.html",
    "href": "posts/tools/SDKMAN.html",
    "title": "SDKMAN",
    "section": "",
    "text": "JAVA 버전관리 용 Git bash에 설치\ncurl -s \"https://get.sdkman.io\" | bash\n경로설정\nC:\\Users\\Administrator\\.sdkman\\bin"
  },
  {
    "objectID": "posts/tools/dcm4che.html",
    "href": "posts/tools/dcm4che.html",
    "title": "DCM4che",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4che/blob/master/README.md\n\n\n\n\n\nbash\n\nuname -m\n\n\n\nkimbi-laptop은 x86_64이므로 linux-x86-64 패키지로 진행\n\n\n\n\n\nSDKMAN(Software Development Kit MANager)은 유닉스 환경에서 여러 소프트웨어 개발 키트를 손쉽게 관리할 수 있는 CLI 도구이다.\n여기에서는 프로젝트별로 Java 버전을 관리(matching)하기 위해 설치하였다.\n\n\n\n\ncurl(Client URL)은 명령줄에서 HTTP, HTTPS, FTP, SCP 등의 프로토콜을 사용하여 데이터를 전송하는 도구인데, Git bash가 설치될 때 같이 설치되므로 git bash에서 아래와 같이 설치하였다.\n\n\n\n\nbash\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n\n\nSDKMAN의 초기화 스크립트를 현재 셸에서 실행하여, SDKMAN 관련 설정과 기능들을 활성화시키는 역할을 합니다.\n\n\n\n\nbash\n\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n\n\n\n\n\nbash\n\nsdk version\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list java\n\n\n\n\n\nbash\n\nsdk install java 17.0.14-tem\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\njava --version\n\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list maven\n\n\n\n\n\nbash\n\nsdk install maven\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\nmvn -version\n\n\n\n\n\n\n\n\n\n\n\nbash\n\ngit clone https://github.com/dcm4che/dcm4che.git\n\n\n\n\n\n\n인터넷연결에 제한적인 정책이 있는 경우 오류가 발생하여 pulic wifi로 진행하였습니다.\n\n\n\n\nbash\n\ncd dcm4che\n./mvnw install\n\n\n\n\n\n\n생각보다 문서가 없습니다.\n\nhttps://github.com/dcm4che/dcm4che",
    "crumbs": [
      "Tools",
      "DCM4che"
    ]
  },
  {
    "objectID": "posts/tools/dcm4che.html#wsl2-ubuntu-환경에서의-설치",
    "href": "posts/tools/dcm4che.html#wsl2-ubuntu-환경에서의-설치",
    "title": "DCM4che",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4che/blob/master/README.md\n\n\n\n\n\nbash\n\nuname -m\n\n\n\nkimbi-laptop은 x86_64이므로 linux-x86-64 패키지로 진행\n\n\n\n\n\nSDKMAN(Software Development Kit MANager)은 유닉스 환경에서 여러 소프트웨어 개발 키트를 손쉽게 관리할 수 있는 CLI 도구이다.\n여기에서는 프로젝트별로 Java 버전을 관리(matching)하기 위해 설치하였다.\n\n\n\n\ncurl(Client URL)은 명령줄에서 HTTP, HTTPS, FTP, SCP 등의 프로토콜을 사용하여 데이터를 전송하는 도구인데, Git bash가 설치될 때 같이 설치되므로 git bash에서 아래와 같이 설치하였다.\n\n\n\n\nbash\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n\n\nSDKMAN의 초기화 스크립트를 현재 셸에서 실행하여, SDKMAN 관련 설정과 기능들을 활성화시키는 역할을 합니다.\n\n\n\n\nbash\n\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n\n\n\n\n\nbash\n\nsdk version\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list java\n\n\n\n\n\nbash\n\nsdk install java 17.0.14-tem\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\njava --version\n\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list maven\n\n\n\n\n\nbash\n\nsdk install maven\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\nmvn -version\n\n\n\n\n\n\n\n\n\n\n\nbash\n\ngit clone https://github.com/dcm4che/dcm4che.git\n\n\n\n\n\n\n인터넷연결에 제한적인 정책이 있는 경우 오류가 발생하여 pulic wifi로 진행하였습니다.\n\n\n\n\nbash\n\ncd dcm4che\n./mvnw install\n\n\n\n\n\n\n생각보다 문서가 없습니다.\n\nhttps://github.com/dcm4che/dcm4che",
    "crumbs": [
      "Tools",
      "DCM4che"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html",
    "href": "posts/tools/Orthanc.html",
    "title": "Orthanc",
    "section": "",
    "text": "벨기에에서 개발한 오픈소스이다. Restful APT를 지원하기 때문에 DICOM query, retrieve, send, move 등을 쉽게 구현할 수 있으리라는기대감으로 설치하여 향후의 시스템을 모사하여 개발을 진행하고 있다.",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#window-운영체제에서의-설치",
    "href": "posts/tools/Orthanc.html#window-운영체제에서의-설치",
    "title": "Orthanc",
    "section": "Window 운영체제에서의 설치",
    "text": "Window 운영체제에서의 설치\n\n완전제거방법\n구동이 제대로 되지 않을 때가 많아서 완전제거방법을 조사하니 아래와 같았다.\n\n서비스 관리자에서 “Orthanc” 서비스를 찾아 중지합니다.\nC:\\Program Files\\Orthanc 폴더를 삭제합니다.\nC:\\Users\\&lt;username&gt;\\AppData\\Local\\Orthanc 폴더를 삭제합니다.\nOrthanc 설정 레지스트리 삭제 (Windows만 해당):\n\nregedit를 실행합니다.\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Orthanc 키를 삭제합니다.\n\n제어판에서 “프로그램 제거”를 선택하고 “Orthanc”를 제거합니다.\n\n\n\n설치파일\n공식사이트 https://orthanc.uclouvain.be/downloads/windows-64/installers/index.html 2025년 2월 27일 release된 25.2.0 버전이 최신이다.\n\n\n설치폴더\n기본설치폴더는 C:\\Program Files\\Orthanc Server이며 data는 C:\\Orthanc에 기본 설치된다. 이를 변경하면 Plugins에서 설치경로 인식의 문제 등으로 실행에 문제가 발생하는 것 같으므로 기본설치폴더에 설치하는 것이 좋겠다.\n\n\n설정파일\nmain 설정파일은 C:\\Program Files\\Orthanc Server\\Configuration\\orthanc.json이다.\n\n\nDICOMModality 설정\n매뉴얼(https://orthanc.uclouvain.be/book/integrations/modality.html#configure-modality)의 예시는 아래와 같았다.\n// The list of the known DICOM modalities\n\"DicomModalities\" : {\n  \"echo1\" : [ \"ECHO1\", \"123.124.125.10\", 104 ]\n},\n위를 참고하여 개발시스템의 DicomModality를 아래와 같이 설정하였다.\n  \"NMDOSE\" : [ \"NMDOSE\", \"127.0.0.1\", 5678 ],\n  \"NMIQ\" : [ \"NMIQ\", \"127.0.0.1\", 5679 ],\n  \"NMFULLDATA\" : [ \"NMFULLDATA\", \"127.0.0.1\", 5680 ],\n  \"NMTEMPSERVER\" : [ \"NMTEMPSERVER\", \"127.0.0.1\", 5681 ],\n  \"ZETTAPACS\" : [ \"ZETTAPACS\", \"127.0.0.1\", 5682 ],\n  \"SLICER\" : [ \"SLICER\", \"127.0.0.1\", 11112 ]\nconfiguration을 설정하는 동안에 Orthanc를 완전히 중지하였다가 수정 후 service를 재개하여야 수정사항이 반영됨을 주의해야 한다. 그리고 쓰기권한이 제한된 경우에는 이를 해결해야 한다.\n\n\nPort\n\n4242\n\n\n\nHPPT port\n\n8042\n\n\n\n설정\n\nPostgreSQL로 DICOM metadata를 저장하기 위해서 postgresql.json을 아래와 같이 설정하였다.\n\n{\n  \"PostgreSQL\" : {\n    \"EnableIndex\" : true,\n    \"EnableStorage\" : false,               // You likely don't need to enable this option\n    \"Host\" : \"localhost\",\n    \"Port\" : 5432,\n    \"Database\" : \"orthanc\",\n    \"Username\" : \"nmuser\",\n    \"Password\" : \"iloveben\",\n    \"Lock\" : true,\n    \"EnableSsl\" : false,                   // New in release 3.0\n    \"MaximumConnectionRetries\" : 10,       // New in release 3.0\n    \"ConnectionRetryInterval\" : 5,         // New in release 3.0\n    \"IndexConnectionsCount\" : 50,          // New in release 4.0 - new default value in 7.0\n    \"TransactionMode\": \"ReadCommitted\",    // New in release 6.0 - new default value in 7.0\n    \"EnableVerboseLogs\": false,            // New in release 6.0\n    \"HousekeepingInterval\": 1,             // New in release 7.0\n    \"AllowInconsistentChildCounts\": false  // New in release 7.2\n  }\n}",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#wsl2ubuntu-환경에서의-설치",
    "href": "posts/tools/Orthanc.html#wsl2ubuntu-환경에서의-설치",
    "title": "Orthanc",
    "section": "WSL2/Ubuntu 환경에서의 설치",
    "text": "WSL2/Ubuntu 환경에서의 설치\n\n패키지 목록 업데이트\n\n\n\nbash\n\nsudo apt update\n\n\n\n\nOrthanc 설치\n\n\n\nbash\n\nsudo apt install orthanc\n\n\n\n\nRemoteAccessAllowed 설정변경\n\n저자가 이해하기로는 내부에서가 아니라 외부에서 접속할 때 true로 설정해야 하는 것이지만 WSL2에서는 이 옵션을 true로 변경해야 가능한 것 같음\n\n\n\n\northanc.json\n\nsudo nano /etc/orthanc/orthanc.json\n\"RemoteAccessAllowed\" : true,\n\n\n\n\nOrthanc 재시작\n\n\n\nbash\n\nsudo systemctl restart orthanc\n\n\n\n\nOrthanc Explorer2 plugin 설치\n\n설치명령이 잘 작동하지 않아서 웹페이지에서 so 파일을 직접 다운로드 하였다.\n\n\n\n\nbrowse\n\nhttps://github.com/orthanc-server/orthanc-explorer-2/releases\n\n\n\nlibOrthancExplorer2-ubuntu.so 파일을 다운로드하여 /usr/share/orthanc/plugins 폴더에 저장하였다.\northanc.json에서 아래와 같이 설정하였다.\n\n\n\n\northanc.json\n\n\"Plugins\" : {\n  \"OrthancExplorer2\" : {\n    \"Enabled\" : true,\n    \"Path\" : \"/usr/share/orthanc/plugins/libOrthancExplorer2-ubuntu.so\"\n  }\n}\n\n\n\nOrthanc을 재시작하였다.\n\n\n\n\nbash\n\nsudo systemctl restart orthanc\n\n\n\n\n\nbash\n\nsudo apt install orthanc-explorer2\n\n\n\n\nWinddow와 통신설정\n\n윈도우는 host",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#스크립트",
    "href": "posts/tools/Orthanc.html#스크립트",
    "title": "Orthanc",
    "section": "스크립트",
    "text": "스크립트\n\nRetrieve 자동화\nOrthanc에 내장된 Lua engine으로 특정기간동안의 Modality==“PT”인 경우를 retrieve하도록 다음의 단계를 진행하였다. - orthanc.json에서 Lua script를 아래와 같이 활성화하였다.\n\"LuaScripts\" : [C:\\\\Orthanc\\\\lua\\\\retrieve_nm_studies.lua\"],\n그러나 query 요청에 실패해 일단 보류\ncurl -X POST http://localhost:8042/tools/execute-script --data-binary \"OnTimer()\"",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  }
]