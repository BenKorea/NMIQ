[
  {
    "objectID": "posts/tools/ubuntu_on_wsl2.html",
    "href": "posts/tools/ubuntu_on_wsl2.html",
    "title": "Ubuntu on WSL2",
    "section": "",
    "text": "유지보수를 간편하게 할려면 도커로 배포 필요 도커는 리눅스환경이 필요하여, 일단은 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "Ubuntu on WSL2"
    ]
  },
  {
    "objectID": "posts/tools/ubuntu_on_wsl2.html#필요성",
    "href": "posts/tools/ubuntu_on_wsl2.html#필요성",
    "title": "Ubuntu on WSL2",
    "section": "",
    "text": "유지보수를 간편하게 할려면 도커로 배포 필요 도커는 리눅스환경이 필요하여, 일단은 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "Ubuntu on WSL2"
    ]
  },
  {
    "objectID": "posts/tools/ubuntu_on_wsl2.html#wsl2-완전-제거",
    "href": "posts/tools/ubuntu_on_wsl2.html#wsl2-완전-제거",
    "title": "Ubuntu on WSL2",
    "section": "2 WSL2 완전 제거",
    "text": "2 WSL2 완전 제거\n\n2.1 VirtualMachinePlatform 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\n2.2 wsl 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\n2.3 재부팅\n\n\n2.4 WSL2 커널 및 배포판 삭제\nC:\\Users\\&lt;사용자이름&gt;\\AppData\\Local\\Packages\\ 에서 Canonical* 폴더 삭제 C:\\Program Files\\WindowsApps 내 Canonical* 폴더 삭제 (권한 필요)\n후자는 권한이 필요하여, C:\\Program Files\\WindowsApps 폴더의 소유자를 변경하는 것보다 아래와 같이 Command Prompt를 관리자권한으로 열어서 del 명령으로 삭제하는 것이 훨씬 간편하다.\n시작메뉴를 누르고 검색에 cmd를 입력하고, 마우스 오른쪽 버튼을 눌러 관리자권한으로 실행한다.\n\n\n\nCommand Prompt\n\ndel /f /q \"C:\\경로\\파일이름\"",
    "crumbs": [
      "Tools",
      "Ubuntu on WSL2"
    ]
  },
  {
    "objectID": "posts/tools/ubuntu_on_wsl2.html#wsl2-설치",
    "href": "posts/tools/ubuntu_on_wsl2.html#wsl2-설치",
    "title": "Ubuntu on WSL2",
    "section": "3 WSL2 설치",
    "text": "3 WSL2 설치\n배포를 도커를 할 예정이라, WSL2를 설치하여 우분투로 설치하고 도커설치를 진행하였다. https://learn.microsoft.com/ko-kr/windows/wsl/install을 참고하여 진행하였다.\n자동설치가 잘 되지 않아서 수동설치를 진행하였다.\n\n3.1 Window edition 및 버전확인\n윈도우 10 HOME 버전의 경우 WSL 1 사용이 불가능했으나, 빌드 19603부터 WSL 2를 지원한다.\n\n\n\n3.2 wsl 옵션 활성화\nPowershell 관리자권한으로 열어서 아래 명령어를 실행한다.\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\n3.3 wsl 옵션 활성화 검증\n\n\n\nPowerShell\n\nwsl --list --verbose\n\n\n\n\n3.4 VirtualMachinePlatform 옵션 활성화\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\n3.5 VirtualMachinePlatform 옵션 활성화 검증\n\n\n\nPowerShell\n\nwsl --set-default-version 2\n\n\n\n\n3.6 Linux 커널 업데이트\n윈도우에 포함된 기본 버전을 업데이트하는 방법도 있다.\n\n\n\nPowerShell\n\nwsl --upgrade\n\n\n아래의 명령을 전후로 사용하면 Kenel의 버전을 비교하여 알 수 있다.\n\n\n\nPowerShell\n\nwsl --status",
    "crumbs": [
      "Tools",
      "Ubuntu on WSL2"
    ]
  },
  {
    "objectID": "posts/tools/ubuntu_on_wsl2.html#우분투-설치",
    "href": "posts/tools/ubuntu_on_wsl2.html#우분투-설치",
    "title": "Ubuntu on WSL2",
    "section": "4 우분투 설치",
    "text": "4 우분투 설치\nMicrosoft Store에서 Ubuntu를 검색하여 설치한다.\n\n4.1 우분투 초기화\n\n\n\nbash\n\nwsl --set-version Ubuntu-20.04 2\n\n\n\n\n4.2 우분투 실행\n시작메뉴에서 Ubuntu를 검색하여 실행한다.\n\n\n4.3 우분투 업데이트\n\n\n\nbash\n\nsudo apt update\nsudo apt upgrade",
    "crumbs": [
      "Tools",
      "Ubuntu on WSL2"
    ]
  },
  {
    "objectID": "posts/tools/Slicer.html",
    "href": "posts/tools/Slicer.html",
    "title": "Slicer",
    "section": "",
    "text": "구축 필요성\n개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.\n\n\nSlicer",
    "crumbs": [
      "Tools",
      "Slicer"
    ]
  },
  {
    "objectID": "posts/tools/PostgreSQL.html",
    "href": "posts/tools/PostgreSQL.html",
    "title": "PostgreSQL",
    "section": "",
    "text": "Berkeley Software Distribution (BSD) license\n\n\n필요성\nOrthanc dicom 저장시 연결하면 속도가 향상되므로 필요\n\n\n설치파일\nhttps://www.enterprisedb.com/downloads/postgres-postgresql-downloads\n\n\n설치방법\n\n프로그램 자체는 default folder에 설치한다.\n그러나 data는 여러가지 목적에 의해서\n\nPC에서는 E:\\17,\n노트북에서는 C:\\17설치하였다.\n\npassworkd는 “postgres”로 진행하고 추후 변경하기로 했다.\npath 설정은 manual로 해야 한다.\n\n\n\nOrthanc의 dicom 저장소로 설정하기\n\ndatabase 만들기\n\nPostgreSQL의 정상실행여부는 윈도우 서비스에서 확인할 수 있고, 다양한 command로도 확인할 수 있다.\n\npsql -U postgres\nCREATE USER nmuser WITH PASSWORD 'iloveben';\nCREATE DATABASE orthanc OWNER nmuser;\nGRANT ALL PRIVILEGES ON DATABASE orthanc TO nmuser;",
    "crumbs": [
      "Tools",
      "PostgreSQL"
    ]
  },
  {
    "objectID": "posts/tools/docker.html",
    "href": "posts/tools/docker.html",
    "title": "Docker",
    "section": "",
    "text": "공식도커사이트(https://docs.docker.com/engine/install/ubuntu/) 내용을 참고하여 진행함",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#사전-준비",
    "href": "posts/tools/docker.html#사전-준비",
    "title": "Docker",
    "section": "사전 준비",
    "text": "사전 준비\n\n방화벽 제한 사항\n어려워서 패스\n\n⚠️ 주의\nufw 또는 firewalld를 사용하여 방화벽을 관리하는 경우, Docker를 통해 컨테이너 포트를 노출하면 방화벽 규칙을 우회할 수 있습니다. 자세한 내용은 Docker와 ufw 문서를 참고하세요.\nDocker는 iptables-nft 및 iptables-legacy만 지원합니다. nft를 사용하여 생성한 방화벽 규칙은 Docker에서 동작하지 않습니다. 방화벽 규칙을 적용하려면 iptables 또는 ip6tables를 사용해야 하며, DOCKER-USER 체인에 추가해야 합니다. 자세한 내용은 패킷 필터링 및 방화벽 문서를 참고하세요.\n\n\n\n운영체제 요구 사항\nDocker Engine을 설치하려면 다음 중 하나의 64비트 우분투(Ubuntu) 버전이 필요합니다.\n\nUbuntu Oracular 24.10\nUbuntu Noble 24.04 (LTS)\nUbuntu Jammy 22.04 (LTS)\nUbuntu Focal 20.04 (LTS)\n\nDocker Engine은 다음 아키텍처를 지원합니다: x86_64 (amd64), armhf, arm64, s390x, ppc64le (ppc64el)\n\n📌 참고:\nUbuntu 기반 배포판(예: Linux Mint)은 공식적으로 지원되지 않습니다.",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#이전-버전-제거",
    "href": "posts/tools/docker.html#이전-버전-제거",
    "title": "Docker",
    "section": "이전 버전 제거",
    "text": "이전 버전 제거\nDocker Engine을 설치하기 전에 충돌을 방지하기 위해 기존의 비공식 Docker 패키지를 제거해야 합니다.\n\n제거해야 하는 패키지 목록:\n\ndocker.io\ndocker-compose\ndocker-compose-v2\ndocker-doc\npodman-docker\ncontainerd\nrunc\n\nfor 명령어를 사용하면 한줄의 명령어로 모두 제거할 수 있습니다.\n\n\n\nBash\n\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n\n\n완벽제거를 위해서는 다음의 문서를 참고하세요. Docker Engine 설치하기 전에 기존 Docker 제거하기",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#설치",
    "href": "posts/tools/docker.html#설치",
    "title": "Docker",
    "section": "설치",
    "text": "설치\n여러가지 설치방법이 있으나 여기서는 apt를 이용한 방법으로 진행\n\nSet up Docker’s apt repository.\n\n\n\nBash\n\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\n\nca-certificates: SSL 인증서를 관리하는 패키지로, HTTPS 연결을 신뢰할 수 있도록 설정합니다.\ncurl: 인터넷에서 파일을 다운로드할 수 있도록 하는 명령줄 도구입니다.\ninstall -m 0755 -d /etc/apt/keyrings\n\nm 0755: 디렉토리의 권한을 0755(소유자는 읽기/쓰기/실행 가능, 다른 사용자는 읽기/실행 가능)로 설정\nd: 디렉토리를 생성하는 옵션\n\nf: 요청 실패 시 에러 메시지를 출력\ns: 진행 상태 메시지를 출력하지 않음\nS: -s 옵션과 함께 사용하여 오류 발생 시 메시지를 출력\nL: 리디렉션이 있는 경우 최종 목적지까지 따라감 다운로드된 GPG 키는 /etc/apt/keyrings/docker.asc에 저장됩니다. chmod a+r /etc/apt/keyrings/docker.asc a+r: 모든 사용자(a: all users)에게 읽기(r: read) 권한을 부여 이 설정이 없으면 apt가 GPG 키를 읽을 수 없기 때문에 저장소 검증이 실패할 수 있습니다.\n\n\n\n\nBash\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n\n\ndeb [옵션] 저장소URL 배포판코드네임 [섹션]의 문법을 따릅니다.\ndeb [arch=\\((dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]\n  - deb: 패키지 저장소를 추가하는 명령어\n  - arch=\\)(dpkg –print-architecture): 현재 시스템의 아키텍처를 출력하는 명령어\n\nsigned-by=/etc/apt/keyrings/docker.asc: GPG 키를 사용하여 저장소를 검증\n\nhttps://download.docker.com/linux/ubuntu\n\n도커 공식 저장소 주소\n\n\\((. /etc/os-release && echo \"\\){UBUNTU_CODENAME:-\\(VERSION_CODENAME}\") stable:\n  - /etc/os-release: 환경변수를 load\n  - && echo \"\\){UBUNTU_CODENAME:-$VERSION_CODENAME}“): CODENAME이 없으면 VERSION_CODENAME을 출력\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\ntee: 파일에 입력한 내용을 출력하고 파일에 저장\n/dev/null: 화면 출력을 무시\n\n\n\n\nInstall the Docker packages.\n\n\n\nBash\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n\n\nVerifying by hello-world\n\n\n\nBash\n\nsudo docker run hello-world",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#portainer-설치",
    "href": "posts/tools/docker.html#portainer-설치",
    "title": "Docker",
    "section": "Portainer 설치",
    "text": "Portainer 설치\n\nPortainer 개념\nPortainer는 Docker 및 Kubernetes 컨테이너 관리를 위한 웹 기반 UI 도구입니다.\nCLI(Command Line Interface) 없이도 컨테이너, 이미지, 네트워크, 볼륨 등을 손쉽게 관리할 수 있습니다.\n\n🔹 주요 기능\n\n컨테이너 관리: 실행, 중지, 삭제, 로그 확인\n이미지 관리: 이미지 다운로드, 삭제, 태그 지정\n네트워크 및 볼륨 관리: 컨테이너 간 네트워크 설정 및 데이터 볼륨 관리\n사용자 및 액세스 제어: 여러 사용자와 권한 설정 가능\nSwarm 및 Kubernetes 지원: Docker Swarm과 Kubernetes 클러스터 관리 가능\n\n\n\n\n\nPortainer 설치 방법\nPortainer는 Docker 컨테이너로 실행되므로, Docker가 설치되어 있어야 합니다.\n\n볼륨 생성\nPortainer의 설정 및 데이터는 볼륨(volume)에 저장됩니다.\n\n\n\nBash\n\ndocker volume create portainer_data\n\n\n\n\nPortainer 컨테이너 실행**\n이는 원격으로 이미지다운로드를 포함한다.\n\n\n\nBash\n\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n\n\n\n-d: 백그라운드에서 컨테이너 실행\n-p 8000:8000 -p 9000:9000: 호스트 포트와 컨테이너 포트 매핑\n--name=portainer: 컨테이너 이름 지정\n--restart=always: 컨테이너가 종료되면 자동으로 재시작\n-v /var/run/docker.sock:/var/run/docker.sock: 호스트의 Docker 소켓을 컨테이너 내부로 연결\n-v portainer_data:/data: Portainer 설정 및 데이터를 저장할 볼륨 연결\nportainer/portainer-ce: Portainer 컨테이너 이미지\n\n\n\n실행중인 container 확인\n\n\n\nBash\n\ndocker ps\n\n\n\n\nPortainer 제거\n\n\n\nBash\n\ndocker stop portainer\ndocker rm -f portainer\n\n\n\n\n로그인 id & password\nben benjamin060318\n\n\n\ndocker-compose\nDocker Compose는 다중 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구입니다. 이 도구를 활용하면 개발 및 배포 과정을 간소화하고 효율적으로 관리할 수 있습니다.\nCompose를 사용하면 하나의 이해하기 쉬운 YAML 구성 파일 내에서 서비스, 네트워크, 볼륨 등을 포함한 전체 애플리케이션 스택을 손쉽게 관리할 수 있습니다. 단 한 개의 명령어로 구성 파일에 명시된 모든 서비스를 생성하고 실행할 수 있다는 점이 큰 장점입니다.\nDocker Compose는 프로덕션, 스테이징, 개발, 테스트 환경은 물론 CI 워크플로우 등 다양한 환경에서 활용될 수 있습니다. 또한, 전체 애플리케이션의 라이프사이클을 관리하기 위한 명령어들을 제공하여,\n서비스 시작, 중지, 재구축 실행 중인 서비스의 상태 확인 실행 중인 서비스의 로그 출력 스트리밍 서비스에 대한 일회성 명령 실행 등의 작업을 손쉽게 수행할 수 있습니다.\n\n설치\n\n\n\nBash\n\nsudo apt-get install docker-compose\n\n\n\n\n\nBash\n\ndocker-compose --version\n\n\n\n\n프로젝트 만들기\n/home/user/docker-compose-test 디렉토리를 생성하고, 해당 디렉토리로 이동합니다.\n\n\ndocker-compose.yml 파일 작성\n\n\n\ndocker-compose.yml\n\nversion: '3'\n\nservices:\n  portainer:\n    image: portainer/portainer-ce:latest\n    container_name: portainer\n    restart: always\n    ports:\n      - \"8000:8000\"  # Portainer Agent 통신용\n      - \"9000:9000\"  # Portainer 웹 UI 접속용 (http://localhost:9000)\n      - \"9443:9443\"  # HTTPS 접속용\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer_data:/data\n\nvolumes:\n  portainer_data:\n\n\n\n\n실행\n\n\n\nBash\n\ndocker compose up -d",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/dcmtk.html",
    "href": "posts/tools/dcmtk.html",
    "title": "DCMTK",
    "section": "",
    "text": "독일의 Office 회사에서 개발한 오픈소스로 C++로 작성되어 속도가 빠르지만 사용법이 어려움\n프로젝트에서는 DCM4che가 쿼리가 원하는 만큼 가능하여 2순위로 둠",
    "crumbs": [
      "Tools",
      "DCMTK"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html",
    "href": "posts/tools/Conquest.html",
    "title": "Conquest",
    "section": "",
    "text": "개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/manual.html",
    "href": "posts/manual.html",
    "title": "사이트사용법",
    "section": "",
    "text": "날짜의 의미\n\n각 웹페이지는 두 가지 날짜가 있으며 이 웹사이트에서는 구별되어 사용되고 있습니다.\n\nPUBLISHED는 최초작성일에 해당하는 개념입니다.\n\n블로그에서 Date-Oldest, Date-Newest 정렬(Order By)할 때 기준으로 사용됩니다.\n\nMODIFIED는 최종수정일에 해당하는 개념입니다.\n\n블로그에서 Default로 정렬할 때 기준으로 사용됩니다.\nDefault로 정렬할 때 내부적으로 MODIFIED 날짜의 최신순으로 되지만, 정렬된 페이지목록에서 각 페이지의 왼쪽의 보여지는 날짜는 MODIFIED가 아닌 PUBLISHED를 보여줍니다. 이로인해 Defalut 정렬에서 각 페이지의 날짜와 정렬이 맞지 않는 것처럼 착각될 수 있으므로 주의를 요합니다.\n\n\n\n\n\n댓글\n\n댓글 기능은 guthub에 가입해야 가능합니다.\n아직 개발중인 기능이라 웹페이지가 갱신될 때 기존 댓글이 사라질 수 있으니 알파/베타 테스터 분들의 양해를 바랍니다."
  },
  {
    "objectID": "posts/dicom/dicom.html",
    "href": "posts/dicom/dicom.html",
    "title": "DICOM",
    "section": "",
    "text": "DICOM",
    "crumbs": [
      "DICOM"
    ]
  },
  {
    "objectID": "posts/development/open_source/others.html",
    "href": "posts/development/open_source/others.html",
    "title": "Open Source",
    "section": "",
    "text": "open source 이용한 반자동화",
    "crumbs": [
      "개발기록",
      "opon source",
      "Open Source"
    ]
  },
  {
    "objectID": "posts/development/NMDose/SpecificCharactorSet_decoding.html",
    "href": "posts/development/NMDose/SpecificCharactorSet_decoding.html",
    "title": "SpeficifCharactorSet decoding",
    "section": "",
    "text": "DICOM에서 사용되는 문자열은 인코딩(Encoding) 시 1~3바이트(또는 그 이상)의 이진 데이터로 저장되며, 이때 인코딩 방식은 SpecificCharacterSet(0008,0005) 태그에 기록된다. 따라서, SpecificCharacterSet의 값에 맞추어 디코딩(Decoding)하면 문자열이 깨지지 않고 올바르게 변환될 수 있다.\n한글이 포함된 문자열은 DICOM에서 최소 두 가지 방식으로 저장될 수 있다. - ISO_IR 149(EUC-KR)는 과거 한글 DICOM 시스템에서 사용되었으며, 완성형 한글만 지원하므로 일부 한글 표현이 제한될 수 있다. - ISO_IR 192(UTF-8)은 유니코드 기반의 인코딩 방식으로 다국어 지원이 가능하며, 최신 DICOM 시스템에서 가장 권장되는 방식이다.\npydicom.dcmread()를 사용하면 DICOM 파일 내의 문자열 데이터는 SpecificCharacterSet(0008,0005)에 따라 자동으로 디코딩되어 Python의 str 객체로 반환됩니다.\n만약에 실제 encoding과 specificcharacterset 지정이 다르면 pydicom 결과는 깨진 문자열이 보이게 되는데, 이 때, 지정대로 다시 encoding해주고 dicom 저장 시 되었던 encoding으로 decoding 한다면 오류를 해결 할 수 있다.\na1_dicom_reader에 정의된 함수에서는 조건과 인코딩과 디코딩이 모두 같은 방식으로 잘 못 만들어진 부분이 있다. 수정이 필요함 2025-02-26\n스캐너 종류에 따라 검사명이 깨어져 있으며 이는 deccoding fix가 되지 않는다.",
    "crumbs": [
      "개발기록",
      "NM Dose",
      "SpeficifCharactorSet decoding"
    ]
  },
  {
    "objectID": "posts/development/development.html",
    "href": "posts/development/development.html",
    "title": "개발기록",
    "section": "",
    "text": "핵의학 영상의 최적화는 품질과 선량을 동시에 고려해야 한다. 그러나 현재는 최적화를 검토하기 위한 기초자료의 생성과정이 수작업에 많이 의존해야 하며, 영상품질은 consensus를 이룬 지표조차 없는 상태이다. 따라서 최적화를 검토하기 위한 기초자료 생성용 프로그램 개발이 필요하다. 이 프로그램은 우선을 선량정보를 추출하는 기능을 구현하고자 한다. 가능할지 모르겠지만 향후에는 영상품질지표까지 추출하는 기능까지 구현하고자 한다.\n개발은 크게 - open source 이용한 반자동화 - 가칭 NMDose 프로그램 개발 - 방사성의약품투여량과 CT dose index를 추출하여 선량-영상관리의 도구로 활용 - 장차 DLR 조사의 도구로 활용하는 것을 목표로 한다. - 가칭 NMIQ 프로그램의 개발 - 장차 영상품질지표를 수집하여 데이터베이스로 구축하여 선량과 연계분석하고 - 장차 영상으로부터 자동으로 영상품질지표를 추출하는 것을 목표로 한다.\n본격적인 개발에 앞서 PACS 시스템을 모사하는 것이 필요하여 다음과 같이 모사하고자 한다.\n\nDICOM 서버\n병원 PACS로부터 선량정보를 추출할 때를 모사하고자 하면, 병원 PACS에 대한 모사 시스템과",
    "crumbs": [
      "개발기록"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "블로그",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nStandardization\n\n\n\n\n\n\nDICOM\n\n\n\n핵릐학 검사명칭 표준화\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCM4chee\n\n\n\n\n\n\nDCM4chee\n\n\n\nDCM4che로 구현한 open source PACS\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nProcedure\n\n\n\n\n\n\nstandardization\n\n\nprocedure\n\n\n\n표준 검사명칭\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nKNMIP\n\n\n\n\n\n\nstandardization\n\n\nKNMIP\n\n\n\nKorea Nuclear Medicine Imaging Proceudure Version v1.0\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCM4che\n\n\n\n\n\n\nDCM4che\n\n\n\nDCM4che toolkit\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpen Source\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\n오픈소스들을 이용한 선량추출 시스템 구축과정을 기록\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpen Source\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\n오픈소스들을 이용한 선량추출 시스템 구축과정을 기록\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nNMDose\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nNMDose\n\n\n\nNMDose 개발과정기록\n\n\n\n\n\nFeb 19, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSpeficifCharactorSet decoding\n\n\n\n\n\n\nNMDose\n\n\nDICOM\n\n\nSpecificCharactorSet\n\n\ndecoding\n\n\n\nNMDose 개발 중 DICOM SpeficifCharactorSet decoding 오류 해결하기\n\n\n\n\n\nFeb 25, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n개발기록\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\n\n개발과정을 기록하여 나의 기억과 협업에 도움이 되고자 함\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nConformance\n\n\n\n\n\n\nDICOM\n\n\nConformance\n\n\n\nDICOM Conformance\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nTools\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\nopen source 이용한 반자동화\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDoseUtility\n\n\n\n\n\n\ndeveolpment\n\n\ndicom\n\n\ndose extrator\n\n\nopen source\n\n\nDoseUtility\n\n\n\nDICOM에서 선량정보 추출 open source\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nConquest\n\n\n\n\n\n\ndicom server\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nUbuntu on WSL2\n\n\n\n\n\n\ndeveolpment\n\n\nopen source\n\n\noperating system\n\n\n\n\n\n\n\n\n\nMar 13, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOpenREM\n\n\n\n\n\n\ndeveolpment\n\n\ndicom\n\n\ndose extrator\n\n\nopen source\n\n\nOpenREM\n\n\n\nDICOM에서 선량정보 추출 open source\n\n\n\n\n\nFeb 19, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDocker\n\n\n\n\n\n\ndocker\n\n\n\nUbuntu에 Docker 설치 및 사용법\n\n\n\n\n\nMar 9, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDCMTK\n\n\n\n\n\n\ndeveolpment\n\n\nnote\n\n\nopen source\n\n\n\nopen source 이용한 반자동화\n\n\n\n\n\nMar 4, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDicoogle\n\n\n\n\n\n\ndicom server\n\n\nDicoogle\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSDKMAN\n\n\n\n\n\n\nJAVA\n\n\n\n개발도구 관리툴\n\n\n\n\n\nMar 7, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n사이트사용법\n\n\n\n\n\n\n사용법\n\n\n\n이 웹사이트 고유의 사용법이 설명되어 있습니다.\n\n\n\n\n\nDec 20, 2024\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nDICOM\n\n\n\n\n\n\nDICOM\n\n\n\nDICOM 공부한 것을 정리하였습니다.\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\n구조\n\n\n\n\n\n\nDICOM\n\n\nstructure\n\n\n\nDICOM 파일의 구조\n\n\n\n\n\nMar 1, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nPostgreSQL\n\n\n\n\n\n\ntools\n\n\nopen source\n\n\ndatabase\n\n\nPostgreSQL\n\n\n\ndatabase open source\n\n\n\n\n\nMar 5, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nOrthanc\n\n\n\n\n\n\ndicom server\n\n\nOrthanc\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\n\n\n\n\n\n\nSlicer\n\n\n\n\n\n\ndicom server\n\n\n\ndicom server open source\n\n\n\n\n\nFeb 26, 2025\n\n\nBenKorea\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/development/NMDose/NMDose.html",
    "href": "posts/development/NMDose/NMDose.html",
    "title": "NMDose",
    "section": "",
    "text": "Dose Report들을 가지고 있는 DICOM Server\n“C:”에 데이터가 있음",
    "crumbs": [
      "개발기록",
      "NM Dose"
    ]
  },
  {
    "objectID": "posts/development/NMDose/NMDose.html#python에서-package의-개념",
    "href": "posts/development/NMDose/NMDose.html#python에서-package의-개념",
    "title": "NMDose",
    "section": "### Python에서 package의 개념",
    "text": "### Python에서 package의 개념\n\nDICOM 읽어오기\n\ndicom_files는 리스트이므로 []로 초기화\nos.walk는 (root, dirs, files) 형태의 튜플을 반환하며 Python의 for loop에서는 리스트나 튜플의 요소를 동시에 할당하는 “언패킹” 기능이 지원되므로 이를 사용\n튜플은 변형할 수 없는 리스트라 할 수 있으며, 리스트에 비해 속도가 빠르고 메모리 사용량이 적으며, 함수 반환 값, 여러 변수 할당(Unpacking), for 루프에서 다중 변수 할당 등에 자주 사용된다.\nendswith()는 str 클래스의 내장 메서드로써 string 문자에 dot 연산자로 붙이면 T/F를 반환함\nfile_path를 만들 때, dirs를 제외함에 주의할 것\npydicom.read는 DICOM을 다루기 위한 목적으로 만들어진 Dataset 클래쓰의 객체를 반환해주며, get method를 이용하면 속성명으로 안전하게 (= 값이 없는 경우에는 default를 지정하여) 조회하여 할 수 있다.\n스캐너 또는 제조사별로 DICOM 문자코딩이 달라 SpecificCharacterSet을 파악하고, 이를 위한 인코딩디코딩 함수를 만들었다. 하지만 인코딩디코딩 오류전략을 잘 못 구현하여 수정이 필요하다. 디버기을 위해서 original_study_description 등을 사용하고 있다.\n\n\n\nimport os\nimport pydicom\n\ndef read_dicom_files(directory):\n    dicom_files = []\n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            if file.endswith(\".dcm\"):\n                file_path = os.path.join(root, file)\n                ds = pydicom.dcmread(file_path, stop_before_pixels=True)\n                character_set = ds.get('SpecificCharacterSet', 'ISO_IR 192')  # UTF-8 as default\n\n                original_study_description = ds.get('StudyDescription', 'N/A')\n                original_patient_name = ds.get('PatientName', 'N/A')\n\n                print(f\"File: {file} - Specific Character Set: {character_set}\")\n\n                if 'StudyDescription' in ds:\n                    study_description = decode_based_on_character_set(ds.StudyDescription, character_set)\n                    ds.StudyDescription = study_description\n                    print(f\"Original Study Description: {original_study_description} -&gt; Decoded: {study_description}\")\n\n                if 'PatientName' in ds:\n                    patient_name = decode_based_on_character_set(ds.PatientName, character_set)\n                    ds.PatientName = patient_name\n                    print(f\"Original Patient Name: {original_patient_name} -&gt; Decoded: {patient_name}\")\n\n                dicom_files.append(ds)\n    return dicom_files\n\ndef decode_based_on_character_set(value, character_set):\n    if character_set == 'ISO_IR 100':\n        return value.encode('iso-8859-1').decode('latin1')\n    elif character_set == 'ISO_IR 192':\n        return value  # UTF-8 encoded, no need to transform\n    elif character_set == 'ISO_IR 149':\n        return value.encode('iso-8859-1').decode('euc-kr')\n    return value  # Default or unknown character set, return as is\n\n# 실행할 디렉토리 경로 설정\ndirectory = r\"C:\\NMDose\\data\"\n\n# 지정된 디렉토리에서 DICOM 파일들을 읽어옵니다.\ndicom_files = read_dicom_files(directory)\n\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024022200491945300000190.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: NOH OK BUN -&gt; Decoded: NOH OK BUN\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024031223303798400000224.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: KIM SUK JA -&gt; Decoded: KIM SUK JA\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024011023285176500000773.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: SEO JUNG YE -&gt; Decoded: SEO JUNG YE\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.221.1704686293.232.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Song Jong Rim -&gt; Decoded: Song Jong Rim\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.221.1704686293.234.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Song Jong Rim -&gt; Decoded: Song Jong Rim\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.345.1710718439.32.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Jung Yang Gu -&gt; Decoded: Jung Yang Gu\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.345.1710718439.34.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Jung Yang Gu -&gt; Decoded: Jung Yang Gu\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024020423410571800001245.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: PARK KEUM SEON -&gt; Decoded: PARK KEUM SEON\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024010923324851500000245.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: KIM JUNG BUN -&gt; Decoded: KIM JUNG BUN\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024013123395351500000200.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: JEON HAE YEONG -&gt; Decoded: JEON HAE YEONG\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.163.1708299137.595.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Kim Gwi Sun -&gt; Decoded: Kim Gwi Sun\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.163.1708299137.597.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Kim Gwi Sun -&gt; Decoded: Kim Gwi Sun\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024010823285431200000274.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: LEE SANG YEONG -&gt; Decoded: LEE SANG YEONG\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.31.1705997406.736.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: (Á¾ÇÕ°ËÁø)F-18 ÇÃ·Î¶óÇ -&gt; Decoded: (Á¾ÇÕ°ËÁø)F-18 ÇÃ·Î¶óÇ\nOriginal Patient Name: Lee Gyeong Seon -&gt; Decoded: Lee Gyeong Seon\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.31.1705997406.738.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: (Á¾ÇÕ°ËÁø)F-18 ÇÃ·Î¶óÇ -&gt; Decoded: (Á¾ÇÕ°ËÁø)F-18 ÇÃ·Î¶óÇ\nOriginal Patient Name: Lee Gyeong Seon -&gt; Decoded: Lee Gyeong Seon\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.30.1707286774.167.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Park Yeong E -&gt; Decoded: Park Yeong E\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.30.1707286774.169.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Park Yeong E -&gt; Decoded: Park Yeong E\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024021400020553100000614.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: KIM MI JA -&gt; Decoded: KIM MI JA\nFile: CT_0999_1.2.840.113619.2.290.3.296522351.31.1705997414.669.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Choi Eul Rye -&gt; Decoded: Choi Eul Rye\nFile: SR_0997_1.2.840.113619.2.290.3.296522351.31.1705997414.671.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾ -&gt; Decoded: F-18 ÇÃ·Î¶óÇÃ·Î³î ³ú ¾\nOriginal Patient Name: Choi Eul Rye -&gt; Decoded: Choi Eul Rye\nFile: CT_0501_1.3.12.2.1107.5.1.4.45592.30000024011823432560900000123.dcm - Specific Character Set: ISO_IR 100\nOriginal Study Description: PET^KCCH_Brain_Alz (Adult) -&gt; Decoded: PET^KCCH_Brain_Alz (Adult)\nOriginal Patient Name: PARK MYUNG JA -&gt; Decoded: PARK MYUNG JA\n\n# 읽어온 DICOM 파일의 개수를 출력합니다.\nprint(f\"dicom 파일 개수: {len(dicom_files)}\")\n\ndicom 파일 개수: 21\n\n\n\ndef filter_dicom_files_by_description(dicom_files):\n    \"\"\"DICOM 파일들을 SeriesDescription에 따라 'Dose Report'와 'Patient Protocol'로 필터링합니다.\"\"\"\n    dose_report_files = []\n    patient_protocol_files = []\n\n    for file in dicom_files:\n        if hasattr(file, 'SeriesDescription'):\n            if file.SeriesDescription == \"Dose Report\":\n                dose_report_files.append(file)\n            elif file.SeriesDescription == \"Patient Protocol\":\n                patient_protocol_files.append(file)\n\n    return dose_report_files, patient_protocol_files\n\n\n# 'Dose Report'와 'Patient Protocol'에 해당하는 파일 필터링\ndose_report_files, patient_protocol_files = filter_dicom_files_by_description(dicom_files)\n\n# 결과 확인\nprint(f\"Dose Report 파일 개수: {len(dose_report_files)}\")\n\nDose Report 파일 개수: 6\n\nprint(f\"Patient Protocol 파일 개수: {len(patient_protocol_files)}\")\n\nPatient Protocol 파일 개수: 9",
    "crumbs": [
      "개발기록",
      "NM Dose"
    ]
  },
  {
    "objectID": "posts/development/open_source/open_source.html",
    "href": "posts/development/open_source/open_source.html",
    "title": "Open Source",
    "section": "",
    "text": "Dose Report Retrieve\n\n병원 PACS로부터 추출하는 것은 시도하지 않았다.\n핵의학과 mini PACS로부터 선량정보를 가지고 있는 DICOM 파일들만 선택적으로 추출 가능한지 검토하였다.\nDiscovery 710에서 Dose Report는 SeriesDescription 태그에 “Dose Report”가 기록되어 있거나 SeriesNumber 태그에 “999”가 기록되어져 있으므로 이를 이용해서 query & retrieve 할 수 있다.\n저자의 병원 Zetta PACS에서는 SeriesDescription이나 SeriesNumber를 필터하여 DICOM send할 수 있는 기능이 없으므로 open source dicom server에서 query & retrieve 하는 방식으로 먼저 접근하였다.\nConquest에서는 SeriesDescription\n\nopen source를 이용해서 추출했을 때 결과는 아래와 같았다.",
    "crumbs": [
      "개발기록",
      "opon source"
    ]
  },
  {
    "objectID": "posts/dicom/conformance/conformance.html",
    "href": "posts/dicom/conformance/conformance.html",
    "title": "Conformance",
    "section": "",
    "text": "Discovery 710/610 Optima 560"
  },
  {
    "objectID": "posts/dicom/information/structure.html",
    "href": "posts/dicom/information/structure.html",
    "title": "구조",
    "section": "",
    "text": "DICOM Structure",
    "crumbs": [
      "DICOM",
      "Information",
      "구조"
    ]
  },
  {
    "objectID": "posts/standardization/standardization.html",
    "href": "posts/standardization/standardization.html",
    "title": "Standardization",
    "section": "",
    "text": "다기관 선량정보수집에 필요한 검사명칭 표준화 현황과 제안",
    "crumbs": [
      "표준화",
      "Standardization"
    ]
  },
  {
    "objectID": "posts/tools/dcm4chee.html",
    "href": "posts/tools/dcm4chee.html",
    "title": "DCM4chee",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host\n\n\n\n\ndocker compose랑 달라서 -이 있는 형태를 설치해야 합니다.\n\n\n\n\nbash\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n\n\n\n\nslapd-dcm4chee, postgres-dcm4chee, dcm4chee-arc 매뉴얼 uid, gid가 999를 넘거나 이미 존재하고 있어, 옵션에 해당하는 이부분을 굳이 변경하여 문제를 일으킬 가능성을 고려하여 설정하지 않고 skip 하였습니다.\nsudo -i 명령으로 프롬프트가 #로 바뀔 수 있음을 주의해야 합니다.\n\n\n\n\nbash\n\n$ sudo -i\ngroupadd -r slapd-dcm4chee --gid=1021 && useradd -r -g slapd-dcm4chee --uid=1021 slapd-dcm4chee\ngroupadd -r postgres-dcm4chee --gid=999 && useradd -r -g postgres-dcm4chee --uid=999 postgres-dcm4chee\ngroupadd -r dcm4chee-arc --gid=1023 && useradd -r -g dcm4chee-arc --uid=1023 dcm4chee-arc\nexit\n\n\n\n\n\n\n\n\nbash\n\nmkdir dcm4chee\nch dcm4chee\n\n\n\n\n\n\n아래의 내용을 복사하여 dcm4chee 폴더에 docker-compose.yml로 저장합니다.\n매뉴얼에는 version이 있지만 불필요한 메세지만 생성되므로 삭제하였습니다.\n\n\n\n\ndocker-compose.yml\n\nservices:\n  ldap:\n    image: dcm4che/slapd-dcm4chee:2.6.7-33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"389:389\"\n    environment:\n      STORAGE_DIR: /storage/fs1\n    volumes:\n      - /var/local/dcm4chee-arc/ldap:/var/lib/openldap/openldap-data\n      - /var/local/dcm4chee-arc/slapd.d:/etc/openldap/slapd.d\n  db:\n    image: dcm4che/postgres-dcm4chee:17.1-33\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n     - \"5432:5432\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/db:/var/lib/postgresql/data\n  arc:\n    image: dcm4che/dcm4chee-arc-psql:5.33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"8080:8080\"\n      - \"8443:8443\"\n      - \"9990:9990\"\n      - \"9993:9993\"\n      - \"11112:11112\"\n      - \"2762:2762\"\n      - \"2575:2575\"\n      - \"12575:12575\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n      WILDFLY_CHOWN: /storage\n      WILDFLY_WAIT_FOR: ldap:389 db:5432\n    depends_on:\n      - ldap\n      - db\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/wildfly:/opt/wildfly/standalone\n      - /var/local/dcm4chee-arc/storage:/storage\n\n\n\n\n\n\n매뉴얼에서는 docker group에 user를 등록하여 문제가 없으나, 저자는 그러지 않았기 때문에 sudo를 하지 않으면 권한문제로 오류가 발생하므로 매뉴얼과 달리 아래와 같이 sudo로 설치해야 합니다.\n\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee up -d\n\n\n\n\n\nhttp://localhost:8080/dcm4chee-arc/ui2\nor\nhttps://localhost:8443/dcm4chee-arc/ui2",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/dicoogle.html",
    "href": "posts/tools/dicoogle.html",
    "title": "Dicoogle",
    "section": "",
    "text": "구축 필요성\n개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.\n\n\nSicoogle",
    "crumbs": [
      "Tools",
      "Dicoogle"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html",
    "href": "posts/tools/Orthanc.html",
    "title": "Orthanc",
    "section": "",
    "text": "벨기에에서 개발한 오픈소스이다. Restful APT를 지원하기 때문에 DICOM query, retrieve, send, move 등을 쉽게 구현할 수 있으리라는기대감으로 설치하여 향후의 시스템을 모사하여 개발을 진행하고 있다.",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/SDKMAN.html",
    "href": "posts/tools/SDKMAN.html",
    "title": "SDKMAN",
    "section": "",
    "text": "JAVA 버전관리 용 Git bash에 설치\ncurl -s \"https://get.sdkman.io\" | bash\n경로설정\nC:\\Users\\Administrator\\.sdkman\\bin"
  },
  {
    "objectID": "posts/tools/dcm4chee.html#docker-compose-설치",
    "href": "posts/tools/dcm4chee.html#docker-compose-설치",
    "title": "DCM4chee",
    "section": "",
    "text": "bash\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n매뉴얼 https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host\n\n\n\ndocker-compose.yml\n\nservices:\n  ldap:\n    image: dcm4che/slapd-dcm4chee:2.6.7-33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"389:389\"\n    environment:\n      STORAGE_DIR: /storage/fs1\n    volumes:\n      - /var/local/dcm4chee-arc/ldap:/var/lib/openldap/openldap-data\n      - /var/local/dcm4chee-arc/slapd.d:/etc/openldap/slapd.d\n  db:\n    image: dcm4che/postgres-dcm4chee:17.1-33\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n     - \"5432:5432\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/db:/var/lib/postgresql/data\n  arc:\n    image: dcm4che/dcm4chee-arc-psql:5.33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"8080:8080\"\n      - \"8443:8443\"\n      - \"9990:9990\"\n      - \"9993:9993\"\n      - \"11112:11112\"\n      - \"2762:2762\"\n      - \"2575:2575\"\n      - \"12575:12575\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n      WILDFLY_CHOWN: /storage\n      WILDFLY_WAIT_FOR: ldap:389 db:5432\n    depends_on:\n      - ldap\n      - db\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/wildfly:/opt/wildfly/standalone\n      - /var/local/dcm4chee-arc/storage:/storage\n\n\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee up -d\n\n\n\nsudo를 하지 않으면 권한문제로 오류가 발생함\n\n\n\n\nhttps\n\nhttp://localhost:8080/dcm4chee-arc/ui2 or https://localhost:8443/dcm4chee-arc/ui2:",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/dcm4che.html",
    "href": "posts/tools/dcm4che.html",
    "title": "DCM4che",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4che/blob/master/README.md\n\n\n\n\n\nbash\n\nuname -m\n\n\n\nkimbi-laptop은 x86_64이므로 linux-x86-64 패키지로 진행\n\n\n\n\n\nSDKMAN(Software Development Kit MANager)은 유닉스 환경에서 여러 소프트웨어 개발 키트를 손쉽게 관리할 수 있는 CLI 도구이다.\n여기에서는 프로젝트별로 Java 버전을 관리(matching)하기 위해 설치하였다.\n\n\n\n\ncurl(Client URL)은 명령줄에서 HTTP, HTTPS, FTP, SCP 등의 프로토콜을 사용하여 데이터를 전송하는 도구인데, Git bash가 설치될 때 같이 설치되므로 git bash에서 아래와 같이 설치하였다.\n\n\n\n\nbash\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n\n\nSDKMAN의 초기화 스크립트를 현재 셸에서 실행하여, SDKMAN 관련 설정과 기능들을 활성화시키는 역할을 합니다.\n\n\n\n\nbash\n\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n\n\n\n\n\nbash\n\nsdk version\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list java\n\n\n\n\n\nbash\n\nsdk install java 17.0.14-tem\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\njava --version\n\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list maven\n\n\n\n\n\nbash\n\nsdk install maven\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\nmvn -version\n\n\n\n\n\n\n\n\n\n\n\nbash\n\ngit clone https://github.com/dcm4che/dcm4che.git\n\n\n\n\n\n\n인터넷연결에 제한적인 정책이 있는 경우 오류가 발생하여 pulic wifi로 진행하였습니다.\n\n\n\n\nbash\n\ncd dcm4che\n./mvnw install\n\n\n\n\n\n\n생각보다 문서가 없습니다.\n\nhttps://github.com/dcm4che/dcm4che",
    "crumbs": [
      "Tools",
      "DCM4che"
    ]
  },
  {
    "objectID": "posts/tools/dcm4che.html#sdkman",
    "href": "posts/tools/dcm4che.html#sdkman",
    "title": "DCM4che",
    "section": "",
    "text": "SDKMAN(Software Development Kit MANager)은 유닉스 환경에서 여러 소프트웨어 개발 키트를 손쉽게 관리할 수 있는 CLI 도구이다.\n여기에서는 프로젝트별로 Java 버전을 관리(matching)하기 위해 설치하였다.\n\n\n\n\ncurl(Client URL)은 명령줄에서 HTTP, HTTPS, FTP, SCP 등의 프로토콜을 사용하여 데이터를 전송하는 도구인데, Git bash가 설치될 때 같이 설치되므로 git bash에서 아래와 같이 설치하였다.\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n설치 경로\n\nSDKMAN은 기본적으로 현재 로그인한 사용자 계정의 홈 디렉토리에 설치된다.\n따라서 로그인 사용자에 따라 아래와 같은 차이가 발생함을 주의해야 한다.\n\nLaptop: C:.sdkman\nDesktop: C:.sdkman\n\n\npath 설정도 manual로 해주어야 한다.\n설치확인은 git bash에서 아래와 같이 입력한다.\n\nsdk version"
  },
  {
    "objectID": "posts/tools/dcm4che.html#java",
    "href": "posts/tools/dcm4che.html#java",
    "title": "DCM4che",
    "section": "JAVA",
    "text": "JAVA\n\n기존 Java가 어떤 프로그램에서 사용되는지 명확하지 않아, 먼저 삭제하고 필요할 때 SDKMAN으로 다시 설치하는 전략으로 진행함. #### 기존 Java 삭제\n제어판 -&gt; 프로그램 및 기능 -&gt; Java 삭제\npath에서도 삭제\n\n\nJAVA 설치\nsdk install java 17.0.8-tem\n설치는 .sdkman/candidates/java/17.0.8-tem에 설치됨\nC:\\Users\\Benjamin\\.sdkman\\candidates\\java\\current\\bin\\java.exe\n\n\nJAVA_HOME 설정\nJAVA_HOME: C:\\Users\\Benjamin\\.sdkman\\candidates\\current\n\n\nPATH 설정\nC:\\Users\\Benjamin\\.sdkman\\candidates\\current\\bin\n\n\nJAVA 설치 확인\njava -version"
  },
  {
    "objectID": "posts/tools/dcm4che.html#dcm4chee-binary-install",
    "href": "posts/tools/dcm4che.html#dcm4chee-binary-install",
    "title": "DCM4che",
    "section": "DCM4chee binary install",
    "text": "DCM4chee binary install\n\nDCM4chee는 open source PACS로서 Java로 구현되어 있어 Java가 필요하다.\nJava가 설치되어 있지 않다면 SDKMAN으로 설치하고, DCM4chee를 설치한다.\nDCM4chee는 binary로 설치 시도 하였지만 압축해제 후 폴더에 실행파일이 없는 오류의 원인을 찾지못해 보류하였다."
  },
  {
    "objectID": "posts/tools/dcm4che.html#apache-maven",
    "href": "posts/tools/dcm4che.html#apache-maven",
    "title": "DCM4che",
    "section": "Apache Maven",
    "text": "Apache Maven\n\nApache Maven은 open source build up 도구이며, DCM4chee source build up이 이미 Maven으로 되어 있어 Maven을 설치하였다.\n\n\n설치\n\nSDKMAN으로 설치하였다.\n\nsdk install maven\n설치된 폴더는 아래와 같았다.\nC:\\Users\\Benjamin\\.sdkman\\candidates\\maven\\\n\n\nPATH 설정\nC:\\Users\\Benjamin\\.sdkman\\candidates\\maven\\current\\bin\n\n\nMAVEN 설치 확인\nmvn -version"
  },
  {
    "objectID": "posts/tools/dcm4che.html#dcm4chee-source-build-up",
    "href": "posts/tools/dcm4che.html#dcm4chee-source-build-up",
    "title": "DCM4che",
    "section": "DCM4chee source build up",
    "text": "DCM4chee source build up\n\nDCM4chee는 source build up이 필요하여 아래의 github를 clone 하였다.\n\ngit clone"
  },
  {
    "objectID": "posts/tools/dcm4che.html#wsl2-ubuntu-환경에서의-설치",
    "href": "posts/tools/dcm4che.html#wsl2-ubuntu-환경에서의-설치",
    "title": "DCM4che",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4che/blob/master/README.md\n\n\n\n\n\nbash\n\nuname -m\n\n\n\nkimbi-laptop은 x86_64이므로 linux-x86-64 패키지로 진행\n\n\n\n\n\nSDKMAN(Software Development Kit MANager)은 유닉스 환경에서 여러 소프트웨어 개발 키트를 손쉽게 관리할 수 있는 CLI 도구이다.\n여기에서는 프로젝트별로 Java 버전을 관리(matching)하기 위해 설치하였다.\n\n\n\n\ncurl(Client URL)은 명령줄에서 HTTP, HTTPS, FTP, SCP 등의 프로토콜을 사용하여 데이터를 전송하는 도구인데, Git bash가 설치될 때 같이 설치되므로 git bash에서 아래와 같이 설치하였다.\n\n\n\n\nbash\n\ncurl -s \"https://get.sdkman.io\" | bash\n\n\n\nSDKMAN의 초기화 스크립트를 현재 셸에서 실행하여, SDKMAN 관련 설정과 기능들을 활성화시키는 역할을 합니다.\n\n\n\n\nbash\n\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n\n\n\n\n\nbash\n\nsdk version\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list java\n\n\n\n\n\nbash\n\nsdk install java 17.0.14-tem\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\njava --version\n\n\n\n\n\n\n\n\n\n\nbash\n\nsdk list maven\n\n\n\n\n\nbash\n\nsdk install maven\n\n\n\n설치 후 bash 재 실행 후 버전을 확인\n\n\n\n\nbash\n\nmvn -version\n\n\n\n\n\n\n\n\n\n\n\nbash\n\ngit clone https://github.com/dcm4che/dcm4che.git\n\n\n\n\n\n\n인터넷연결에 제한적인 정책이 있는 경우 오류가 발생하여 pulic wifi로 진행하였습니다.\n\n\n\n\nbash\n\ncd dcm4che\n./mvnw install\n\n\n\n\n\n\n생각보다 문서가 없습니다.\n\nhttps://github.com/dcm4che/dcm4che",
    "crumbs": [
      "Tools",
      "DCM4che"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#구축-필요성",
    "href": "posts/tools/Conquest.html#구축-필요성",
    "title": "Conquest",
    "section": "",
    "text": "개발 단계에서 실제 PACS를 모사할 수 있는 별도의 DICOM 서버를 구축할 필요가 아래와 같은 오픈소스들을 검토하였다.",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#window-운영체제에서의-설치",
    "href": "posts/tools/Conquest.html#window-운영체제에서의-설치",
    "title": "Conquest",
    "section": "Window 운영체제에서의 설치",
    "text": "Window 운영체제에서의 설치\n\n설치파일\n최신 설치파일은 공식사이트가 아닌 Cnquest User Forum에 공개된 2024년 9월 25일 release된 버전 1.5.0e (dicomserver-1.5.0e.zip, https://forum.iq-image.com/forum/index.php?thread/50654-conquest-1-5-0e-released/)가 최신이다.\n\n\n설치방법\n설치방법은 원하는 폴더에서 설치파일의 압축을 풀면된다. 업그레이드시에는 매뉴얼에 따르면 다음의 지시를 따르면 된다. - 기본적으로 exe 및 dll 파일을 교체하면 업데이트 가능하지만, - 일부 설정 파일(dicom.sql, dgatesop.lst, dicom.ini)을 조정할 경우 데이터베이스를 다시 생성해야 할 수도 있습니다. - 서버는 반드시 업데이트 전에 중지해야 하며, 서비스로 실행 중이면 제어판에서 중지 또는 서비스 해제가 필요합니다. - 데이터베이스 재생성이 필요한 경우 매우 오랜 시간이 걸릴 수 있으므로 주의해야 합니다. - 기존 데이터를 유지하려면 dicom.sql을 백업 후 복원하는 것이 좋습니다. - 저자의 경우는 data폴더, acrnema.map, dicom.ini 파일을 제외하고 삭제한 뒤 설치압축파일을 풀면 데이터와 설정이 유지된 체로 업그레이드 하고 database reganeration을 하였다.\n\n\n활용 현황\n이 서버프로그램으로 저자는 NMDose, NMIQ, NMFullData, NMTEMPSERVER, ZettaPACS를 구축하여 선량분석시스템, 영상품질자동화, clinical PACS모사, 임시서버, clinical PACS 모사의 목적으로 사용하고 있다.\n\n\nLua script\n쿼리를 정교하게 할 수 있다.\n\n\n저장파일의 이름을 지정하는 방식\n%id_%studydate%modality_%series_%sopuid.dcm",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/Conquest.html#wsl2-ununtu에서의-설치",
    "href": "posts/tools/Conquest.html#wsl2-ununtu에서의-설치",
    "title": "Conquest",
    "section": "WSL2 Ununtu에서의 설치",
    "text": "WSL2 Ununtu에서의 설치\n\n준비\n\n\n\nbash\n\nsudo apt install build-essential g++ make apache2 php libapache2-mod-php php-sqlite3 unzip p7zip-full lua5.1 liblua5.1-0-dev lua-socket luarocks liblua5.1-0\n\n\n\n\n\nbash\n\nsudo luarocks install luafilesystem\n\n\n\n\n\nbash\n\nsudo a2enmod cgi\nsudo a2enmod rewrite\nsudo sed -i 's/AllowOverride None/AllowOverride All/g' /etc/apache2/apache2.conf\nsudo sed -i 's/memory_limit = 128M/memory_limit = 512M/g' /etc/php/*/apache2/php.ini\nsudo sed -i 's/upload_max_filesize = 2M/upload_max_filesize = 250M/g' /etc/php/*/apache2/php.ini\nsudo sed -i 's/post_max_size = 8M/post_max_size = 250M/g' /etc/php/*/apache2/php.ini\nsudo systemctl restart apache2\n\n\n\n\n설치파일 다운로드\n\n\n\nbash\n\nwget http://natura-ingenium.nl/dicomserver/dicomserver150e.zip\nmkdir conquest\ncd conquest\nunzip ../dicomserver150e.zip\nrm ../dicomserver150e.zip\n\n\n\n\n컴파일\n\n\n\nbash\n\nchmod 777 maklinux\n./maklinux\n\n\n\nchoose option 3 or 5 SqLite or SqlLite precompiled\nsay ‘y’ to ‘Regenerate the database’ Deletes previous database contents\nsay ‘y’ to ‘Install as service’ Shows status hit ‘q’ to return\n\n비록 아래의 메세지가 나오더라도 정상임\nFailed to stop conquest.service: Unit conquest.service not loaded.\n\n\n\n\n브라우저로 접속\n\nhttp://localhost/app/newweb/ 또는 http://localhost/app/ohif 주소로 접속\n\n\n\nsystemd 설정\n\ndaemon으로 설정되어 있으므로 systemctl로 관리할 수 있다.\n만약에 설정파일을 변경한 후 재시작을 할려면 아래와 같이 한다.\n\n\n\n\nbash\n\nsudo systemctl restart conquest\n\n\n\n정상작동이 되지 않는다고 생각되면 dgate가 아래의 명령으로 실행되고 있는지 확인해 본다.\n\n\n\n\nbash\n\nsystemctl status conquest",
    "crumbs": [
      "Tools",
      "Conquest"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html",
    "href": "posts/tools/wsl2_ubuntu.html",
    "title": "WSL2/Ubuntu",
    "section": "",
    "text": "개발환경으로써 리눅스가 가장 유리하겠으나, 현단계에서는 WSL2를 대안으로 선택함\n특히, NMIQ의 설치는 도커배포를 계획하고 있어 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#필요성",
    "href": "posts/tools/wsl2_ubuntu.html#필요성",
    "title": "WSL2/Ubuntu",
    "section": "",
    "text": "개발환경으로써 리눅스가 가장 유리하겠으나, 현단계에서는 WSL2를 대안으로 선택함\n특히, NMIQ의 설치는 도커배포를 계획하고 있어 윈도우10에서 WSL2을 활성화 필요",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#wsl2상의-우분투-완전-제거",
    "href": "posts/tools/wsl2_ubuntu.html#wsl2상의-우분투-완전-제거",
    "title": "WSL2/Ubuntu",
    "section": "WSL2상의 우분투 완전 제거",
    "text": "WSL2상의 우분투 완전 제거\n\n우분투버전 확인\n\nCommand Prompt를 관리자권한으로 가장 빠르게 여는 방법은 Win+X입니다.\n아래의 명령으로 설치된 Linux 배포판을 확인합니다.\n\n\n\n\n관리자권한 Command Prompt\n\n wsl --list --verbose\n\n\n또는\n\n\n\n관리자권한 Command Prompt\n\n wsl -l -v\n\n\n\n\n우분투 등록 취소 및 제거\n아래와 같이 Linux 배포판의 등록을 취소하고 제거합니다.\n\n\n\n관리자권한 Command Prompt\n\nwsl --unregister Ubuntu-24.04\n\n\n\n이때 완료라는 메세지가 출력됩니다.\n이렇게 하면 우분투가 사용하는 가상 디스크(ext4.vhdx)파일도 자동으로 삭제되어 편리하며 혹시 오류가 있어 삭제되지 않을 수 있으므로 확인하는 것이 바람직합니다.\n\nC:\\Users\\&lt;사용자이름&gt;\\AppData\\Local\\Packages\\ 에서 Canonical* 폴더 삭제\nC:\\Program Files\\WindowsApps 내 Canonical* 폴더 삭제 (권한 필요)\n\n후자는 권한이 필요하여, C:\\Program Files\\WindowsApps 폴더의 소유자를 변경하는 것보다 아래와 같이 Command Prompt를 관리자권한으로 열어서 del 명령으로 삭제하는 것이 훨씬 간편하다.\n\n시작메뉴를 누르고 검색에 cmd를 입력하고, 마우스 오른쪽 버튼을 눌러 관리자권한으로 실행한다.\n\n\n\n\n\nCommand Prompt\n\ndel /f /q \"C:\\경로\\파일이름\"\n\n\n\n\n윈도우에서 앱제거\n\n시작메뉴를 누르고 설정을 클릭하고, 앱을 클릭하여 Ubuntu를 검색하여 제거합니다.\n\n\n\n재부팅\n\n\nVirtualMachinePlatform 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\nwsl 제거\n\n\n\nPowerShell\n\ndism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\n재부팅",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#wsl2-설치",
    "href": "posts/tools/wsl2_ubuntu.html#wsl2-설치",
    "title": "WSL2/Ubuntu",
    "section": "WSL2 설치",
    "text": "WSL2 설치\n\nWindow edition 및 버전확인\n윈도우 10 HOME 버전의 경우 ARM64 시스템의 경우 빌드 19041부터 WSL 2를 지원한다.\n\n\n\n\nWSL 설치명령\n이전과는 다르게 아래의 자동화된 명령한 줄로 설치가 됩니다.\n\n\n\nPowerShell\n\nwsl --install\n\n\n이는 wsl 옵션과 가상머신플랫폼을 활성화시키고 최신 리눅스커널까지 upgrade해 줍니다.\n\n\n재부팅\n변경사항을 적용하기 위해서는 시스템을 다시 시작하라는 메세지가 나옵니다.\n\n\n중간점검\n\nWin+X+A로 관리자권한 Command Prompt를 열어서\n\n리눅스커널이 정상작동하는지 아래의 명령어로 확인합니다.\n\n\n\n\n\n관리자: 명령 프롬프트\n\nwsl --version\n\n\nWSL 버전과 커널버전까지 표시되므로 확인할 수 있습니다.",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#우분투설치",
    "href": "posts/tools/wsl2_ubuntu.html#우분투설치",
    "title": "WSL2/Ubuntu",
    "section": "우분투설치",
    "text": "우분투설치\n\n관리자권한 Command Prompt에서 다음의 명령을 입력하여 최신 배포판을 설치할 수 있습니다.\n그런데 방화벽이나 회상방침에 따라 인터넷 연결이 제한적인 경우에는 문제가 발생하여 Public WiFi로 전환하면 성공하게 됩니다.\n\n\n\n\n관리자: 명령 프롬프트\n\nwsl --install -d Ubuntu\n\n\n\ndefault Unix user accout\n\n소문자가 바람직하다.\npasswd를 입력하라는 메세지가 나오면, 비밀번호를 입력한다.\n\n\n\n우분투 디렉토리 구조\n\n\n\n/\n├── bin → /usr/bin         # 주요 실행 파일 (ls, cp 등)이 위치한 디렉토리. 기본 명령어 포함.\n├── boot                   # 부팅 관련 파일이 저장됨 (커널, grub 등).\n├── dev                    # 장치 파일(device files)이 위치 (예: /dev/sda, /dev/null 등).\n├── etc                    # 시스템 설정 파일(configuration files)이 저장된 곳.\n├── home                   # 일반 사용자들의 홈 디렉토리 (예: /home/username).\n├── lib → /usr/lib         # 공유 라이브러리(.so 파일)들이 저장된 디렉토리.\n├── lib64 → /usr/lib64     # 64비트 라이브러리들이 저장됨.\n├── media                  # USB, CD-ROM 등의 자동 마운트 지점.\n├── mnt                    # 외부 장치를 수동으로 마운트할 때 사용하는 디렉토리.\n├── opt                    # 서드파티 애플리케이션들이 설치되는 디렉토리 (예: /opt/google).\n├── proc                   # 실행 중인 프로세스 및 커널 정보가 담긴 가상 파일 시스템.\n├── root                   # root(관리자) 사용자의 홈 디렉토리.\n├── run                    # 부팅 후 생성되는 임시 런타임 데이터가 저장됨.\n├── sbin → /usr/sbin       # 시스템 관리 명령어들이 위치 (예: reboot, iptables 등).\n├── srv                    # 웹, FTP 등 서비스를 위한 데이터 저장용 디렉토리.\n├── sys                    # 시스템 하드웨어 및 장치 정보에 접근하는 가상 파일 시스템.\n├── tmp                    # 임시 파일 저장소. 재부팅 시 대부분 삭제됨.\n├── usr                    # 사용자 명령어 및 라이브러리 저장소.\n│   ├── bin                # 대부분의 사용자 명령어들이 위치.\n│   ├── lib                # 라이브러리 파일들.\n│   ├── lib64              # 64비트 전용 라이브러리.\n│   ├── sbin               # 시스템 명령어.\n│   └── share              # 공유 데이터 (man page, 아이콘 등).\n└── var                    # 로그, 캐시, 메일 등 자주 변경되는 파일 저장소.\n    ├── log                # 시스템 로그 파일 저장소.\n    ├── cache              # 애플리케이션 캐시.\n    └── tmp                # 임시 파일 저장소 (보다 긴 기간 유지될 수 있음).\n\n\nFigure 1: Ubuntu의 디렉토리 구조",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#이전설치방식",
    "href": "posts/tools/wsl2_ubuntu.html#이전설치방식",
    "title": "WSL2/Ubuntu",
    "section": "이전설치방식",
    "text": "이전설치방식\n\nwsl 옵션 활성화\n\nPowershell 관리자권한으로 열어서 아래 명령어를 실행한다.\n\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /norestart\n\n\n\n\nVirtualMachinePlatform 옵션 활성화\n\n\n\nPowerShell\n\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /norestart\n\n\n\n\nLinux 커널 업데이트\n윈도우에 포함된 기본 버전을 업데이트하는 방법도 있다.\n\n\n\nPowerShell\n\nwsl --upgrade\n\n\n아래의 명령을 전후로 사용하면 Kenel의 버전을 비교하여 알 수 있다.\n\n\n\nPowerShell\n\nwsl --status",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/docker.html#wsl2ubuntu에서의-설치",
    "href": "posts/tools/docker.html#wsl2ubuntu에서의-설치",
    "title": "Docker",
    "section": "WSL2/Ubuntu에서의 설치",
    "text": "WSL2/Ubuntu에서의 설치\n\n이전 버전 제거\nDocker Engine을 설치하기 전에 충돌을 방지하기 위해 기존의 비공식 Docker 패키지를 제거해야 합니다.\n\n제거해야 하는 패키지 목록:\n\ndocker.io\ndocker-compose\ndocker-compose-v2\ndocker-doc\npodman-docker\ncontainerd\nrunc\n\nfor 명령어를 사용하면 한줄의 명령어로 모두 제거할 수 있습니다.\n\n\n\nBash\n\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n\n\n완벽제거를 위해서는 다음의 문서를 참고하세요. Docker Engine 설치하기 전에 기존 Docker 제거하기\n\n\n\n설치\n여러가지 설치방법이 있으나 여기서는 apt를 이용한 방법으로 진행\n\nSet up Docker’s apt repository.\n\n\n\nBash\n\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\n\nca-certificates: SSL 인증서를 관리하는 패키지로, HTTPS 연결을 신뢰할 수 있도록 설정합니다.\ncurl: 인터넷에서 파일을 다운로드할 수 있도록 하는 명령줄 도구입니다.\ninstall -m 0755 -d /etc/apt/keyrings\n\nm 0755: 디렉토리의 권한을 0755(소유자는 읽기/쓰기/실행 가능, 다른 사용자는 읽기/실행 가능)로 설정\nd: 디렉토리를 생성하는 옵션\n\nf: 요청 실패 시 에러 메시지를 출력\ns: 진행 상태 메시지를 출력하지 않음\nS: -s 옵션과 함께 사용하여 오류 발생 시 메시지를 출력\nL: 리디렉션이 있는 경우 최종 목적지까지 따라감 다운로드된 GPG 키는 /etc/apt/keyrings/docker.asc에 저장됩니다. chmod a+r /etc/apt/keyrings/docker.asc a+r: 모든 사용자(a: all users)에게 읽기(r: read) 권한을 부여 이 설정이 없으면 apt가 GPG 키를 읽을 수 없기 때문에 저장소 검증이 실패할 수 있습니다.\n\n\n\n\nBash\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n\n\ndeb [옵션] 저장소URL 배포판코드네임 [섹션]의 문법을 따릅니다.\ndeb [arch=\\((dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]\n  - deb: 패키지 저장소를 추가하는 명령어\n  - arch=\\)(dpkg –print-architecture): 현재 시스템의 아키텍처를 출력하는 명령어\n\nsigned-by=/etc/apt/keyrings/docker.asc: GPG 키를 사용하여 저장소를 검증\n\nhttps://download.docker.com/linux/ubuntu\n\n도커 공식 저장소 주소\n\n\\((. /etc/os-release && echo \"\\){UBUNTU_CODENAME:-\\(VERSION_CODENAME}\") stable:\n  - /etc/os-release: 환경변수를 load\n  - && echo \"\\){UBUNTU_CODENAME:-$VERSION_CODENAME}“): CODENAME이 없으면 VERSION_CODENAME을 출력\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\ntee: 파일에 입력한 내용을 출력하고 파일에 저장\n/dev/null: 화면 출력을 무시\n\n\n\n\nInstall the Docker packages.\n\n\n\nBash\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n\n\nVerifying by hello-world\n\n\n\nBash\n\nsudo docker run hello-world\n\n\nDocker 설치 파일 구조 (Ubuntu 기준)\n/\n├── usr/\n│   ├── bin/\n│   │   ├── docker               ← Docker CLI 실행 파일\n│   │   ├── docker-compose       ← Docker Compose (별도 설치 시)\n│   │   ├── containerd           ← 컨테이너 런타임\n│   │   └── runc                 ← 컨테이너 실행기\n│   └── share/\n│       └── docker-engine/       ← (있을 경우) 문서, 기본 설정 등\n│\n├── etc/\n│   └── docker/\n│       └── daemon.json          ← Docker 데몬 설정 파일\n│\n├── var/\n│   ├── lib/\n│   │   └── docker/              ← 이미지, 컨테이너, 볼륨 등 저장소\n│   └── run/\n│       └── docker.sock          ← Docker 데몬 통신용 소켓 파일\n│\n├── lib/\n│   └── systemd/\n│       └── system/\n│           └── docker.service   ← systemd 서비스 유닛 파일\n│\n├── etc/\n│   └── systemd/\n│       └── system/\n│           └── docker.service.d/ ← 사용자 정의 systemd 설정 디렉터리\n│\n└── home/\n    └── 사용자명/\n        └── .docker/             ← 사용자 설정, 인증 토큰 등\n\n\n\ndocker-compose\nDocker Compose는 다중 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구입니다. 이 도구를 활용하면 개발 및 배포 과정을 간소화하고 효율적으로 관리할 수 있습니다.\nCompose를 사용하면 하나의 이해하기 쉬운 YAML 구성 파일 내에서 서비스, 네트워크, 볼륨 등을 포함한 전체 애플리케이션 스택을 손쉽게 관리할 수 있습니다. 단 한 개의 명령어로 구성 파일에 명시된 모든 서비스를 생성하고 실행할 수 있다는 점이 큰 장점입니다.\nDocker Compose는 프로덕션, 스테이징, 개발, 테스트 환경은 물론 CI 워크플로우 등 다양한 환경에서 활용될 수 있습니다. 또한, 전체 애플리케이션의 라이프사이클을 관리하기 위한 명령어들을 제공하여,\n서비스 시작, 중지, 재구축 실행 중인 서비스의 상태 확인 실행 중인 서비스의 로그 출력 스트리밍 서비스에 대한 일회성 명령 실행 등의 작업을 손쉽게 수행할 수 있습니다.\n\n설치\n\n\n\nBash\n\nsudo apt-get install docker-compose\n\n\n\n\n\nBash\n\ndocker-compose --version\n\n\n\n\n프로젝트 만들기\n/home/user/docker-compose-test 디렉토리를 생성하고, 해당 디렉토리로 이동합니다.\n\n\ndocker-compose.yml 파일 작성\n\n\n\ndocker-compose.yml\n\nversion: '3'\n\nservices:\n  portainer:\n    image: portainer/portainer-ce:latest\n    container_name: portainer\n    restart: always\n    ports:\n      - \"8000:8000\"  # Portainer Agent 통신용\n      - \"9000:9000\"  # Portainer 웹 UI 접속용 (http://localhost:9000)\n      - \"9443:9443\"  # HTTPS 접속용\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer_data:/data\n\nvolumes:\n  portainer_data:\n\n\n\n\n실행\n\n\n\nBash\n\ndocker compose up -d",
    "crumbs": [
      "Tools",
      "Docker"
    ]
  },
  {
    "objectID": "posts/tools/portainder.html",
    "href": "posts/tools/portainder.html",
    "title": "Docker",
    "section": "",
    "text": "공식도커사이트(https://docs.docker.com/engine/install/ubuntu/) 내용을 참고하여 진행함"
  },
  {
    "objectID": "posts/tools/portainder.html#사전-준비",
    "href": "posts/tools/portainder.html#사전-준비",
    "title": "Docker",
    "section": "사전 준비",
    "text": "사전 준비\n\n방화벽 제한 사항\n어려워서 패스\n\n⚠️ 주의\nufw 또는 firewalld를 사용하여 방화벽을 관리하는 경우, Docker를 통해 컨테이너 포트를 노출하면 방화벽 규칙을 우회할 수 있습니다. 자세한 내용은 Docker와 ufw 문서를 참고하세요.\nDocker는 iptables-nft 및 iptables-legacy만 지원합니다. nft를 사용하여 생성한 방화벽 규칙은 Docker에서 동작하지 않습니다. 방화벽 규칙을 적용하려면 iptables 또는 ip6tables를 사용해야 하며, DOCKER-USER 체인에 추가해야 합니다. 자세한 내용은 패킷 필터링 및 방화벽 문서를 참고하세요.\n\n\n\n운영체제 요구 사항\nDocker Engine을 설치하려면 다음 중 하나의 64비트 우분투(Ubuntu) 버전이 필요합니다.\n\nUbuntu Oracular 24.10\nUbuntu Noble 24.04 (LTS)\nUbuntu Jammy 22.04 (LTS)\nUbuntu Focal 20.04 (LTS)\n\nDocker Engine은 다음 아키텍처를 지원합니다: x86_64 (amd64), armhf, arm64, s390x, ppc64le (ppc64el)\n\n📌 참고:\nUbuntu 기반 배포판(예: Linux Mint)은 공식적으로 지원되지 않습니다."
  },
  {
    "objectID": "posts/tools/portainder.html#이전-버전-제거",
    "href": "posts/tools/portainder.html#이전-버전-제거",
    "title": "Docker",
    "section": "이전 버전 제거",
    "text": "이전 버전 제거\nDocker Engine을 설치하기 전에 충돌을 방지하기 위해 기존의 비공식 Docker 패키지를 제거해야 합니다.\n\n제거해야 하는 패키지 목록:\n\ndocker.io\ndocker-compose\ndocker-compose-v2\ndocker-doc\npodman-docker\ncontainerd\nrunc\n\nfor 명령어를 사용하면 한줄의 명령어로 모두 제거할 수 있습니다.\n\n\n\nBash\n\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\n\n\n완벽제거를 위해서는 다음의 문서를 참고하세요. Docker Engine 설치하기 전에 기존 Docker 제거하기"
  },
  {
    "objectID": "posts/tools/portainder.html#설치",
    "href": "posts/tools/portainder.html#설치",
    "title": "Docker",
    "section": "설치",
    "text": "설치\n여러가지 설치방법이 있으나 여기서는 apt를 이용한 방법으로 진행\n\nSet up Docker’s apt repository.\n\n\n\nBash\n\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n\n\nca-certificates: SSL 인증서를 관리하는 패키지로, HTTPS 연결을 신뢰할 수 있도록 설정합니다.\ncurl: 인터넷에서 파일을 다운로드할 수 있도록 하는 명령줄 도구입니다.\ninstall -m 0755 -d /etc/apt/keyrings\n\nm 0755: 디렉토리의 권한을 0755(소유자는 읽기/쓰기/실행 가능, 다른 사용자는 읽기/실행 가능)로 설정\nd: 디렉토리를 생성하는 옵션\n\nf: 요청 실패 시 에러 메시지를 출력\ns: 진행 상태 메시지를 출력하지 않음\nS: -s 옵션과 함께 사용하여 오류 발생 시 메시지를 출력\nL: 리디렉션이 있는 경우 최종 목적지까지 따라감 다운로드된 GPG 키는 /etc/apt/keyrings/docker.asc에 저장됩니다. chmod a+r /etc/apt/keyrings/docker.asc a+r: 모든 사용자(a: all users)에게 읽기(r: read) 권한을 부여 이 설정이 없으면 apt가 GPG 키를 읽을 수 없기 때문에 저장소 검증이 실패할 수 있습니다.\n\n\n\n\nBash\n\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n\n\n\ndeb [옵션] 저장소URL 배포판코드네임 [섹션]의 문법을 따릅니다.\ndeb [arch=\\((dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc]\n  - deb: 패키지 저장소를 추가하는 명령어\n  - arch=\\)(dpkg –print-architecture): 현재 시스템의 아키텍처를 출력하는 명령어\n\nsigned-by=/etc/apt/keyrings/docker.asc: GPG 키를 사용하여 저장소를 검증\n\nhttps://download.docker.com/linux/ubuntu\n\n도커 공식 저장소 주소\n\n\\((. /etc/os-release && echo \"\\){UBUNTU_CODENAME:-\\(VERSION_CODENAME}\") stable:\n  - /etc/os-release: 환경변수를 load\n  - && echo \"\\){UBUNTU_CODENAME:-$VERSION_CODENAME}“): CODENAME이 없으면 VERSION_CODENAME을 출력\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\ntee: 파일에 입력한 내용을 출력하고 파일에 저장\n/dev/null: 화면 출력을 무시\n\n\n\n\nInstall the Docker packages.\n\n\n\nBash\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n\n\nVerifying by hello-world\n\n\n\nBash\n\nsudo docker run hello-world"
  },
  {
    "objectID": "posts/tools/portainder.html#portainer-설치",
    "href": "posts/tools/portainder.html#portainer-설치",
    "title": "Docker",
    "section": "Portainer 설치",
    "text": "Portainer 설치\n\nPortainer 개념\nPortainer는 Docker 및 Kubernetes 컨테이너 관리를 위한 웹 기반 UI 도구입니다.\nCLI(Command Line Interface) 없이도 컨테이너, 이미지, 네트워크, 볼륨 등을 손쉽게 관리할 수 있습니다.\n\n🔹 주요 기능\n\n컨테이너 관리: 실행, 중지, 삭제, 로그 확인\n이미지 관리: 이미지 다운로드, 삭제, 태그 지정\n네트워크 및 볼륨 관리: 컨테이너 간 네트워크 설정 및 데이터 볼륨 관리\n사용자 및 액세스 제어: 여러 사용자와 권한 설정 가능\nSwarm 및 Kubernetes 지원: Docker Swarm과 Kubernetes 클러스터 관리 가능\n\n\n\n\n\nPortainer 설치 방법\nPortainer는 Docker 컨테이너로 실행되므로, Docker가 설치되어 있어야 합니다.\n\n볼륨 생성\nPortainer의 설정 및 데이터는 볼륨(volume)에 저장됩니다.\n\n\n\nBash\n\ndocker volume create portainer_data\n\n\n\n\nPortainer 컨테이너 실행**\n이는 원격으로 이미지다운로드를 포함한다.\n\n\n\nBash\n\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce\n\n\n\n-d: 백그라운드에서 컨테이너 실행\n-p 8000:8000 -p 9000:9000: 호스트 포트와 컨테이너 포트 매핑\n--name=portainer: 컨테이너 이름 지정\n--restart=always: 컨테이너가 종료되면 자동으로 재시작\n-v /var/run/docker.sock:/var/run/docker.sock: 호스트의 Docker 소켓을 컨테이너 내부로 연결\n-v portainer_data:/data: Portainer 설정 및 데이터를 저장할 볼륨 연결\nportainer/portainer-ce: Portainer 컨테이너 이미지\n\n\n\n실행중인 container 확인\n\n\n\nBash\n\ndocker ps\n\n\n\n\nPortainer 제거\n\n\n\nBash\n\ndocker stop portainer\ndocker rm -f portainer\n\n\n\n\n로그인 id & password\nben benjamin060318\n\n\n\ndocker-compose\nDocker Compose는 다중 컨테이너 애플리케이션을 정의하고 실행하기 위한 도구입니다. 이 도구를 활용하면 개발 및 배포 과정을 간소화하고 효율적으로 관리할 수 있습니다.\nCompose를 사용하면 하나의 이해하기 쉬운 YAML 구성 파일 내에서 서비스, 네트워크, 볼륨 등을 포함한 전체 애플리케이션 스택을 손쉽게 관리할 수 있습니다. 단 한 개의 명령어로 구성 파일에 명시된 모든 서비스를 생성하고 실행할 수 있다는 점이 큰 장점입니다.\nDocker Compose는 프로덕션, 스테이징, 개발, 테스트 환경은 물론 CI 워크플로우 등 다양한 환경에서 활용될 수 있습니다. 또한, 전체 애플리케이션의 라이프사이클을 관리하기 위한 명령어들을 제공하여,\n서비스 시작, 중지, 재구축 실행 중인 서비스의 상태 확인 실행 중인 서비스의 로그 출력 스트리밍 서비스에 대한 일회성 명령 실행 등의 작업을 손쉽게 수행할 수 있습니다.\n\n설치\n\n\n\nBash\n\nsudo apt-get install docker-compose\n\n\n\n\n\nBash\n\ndocker-compose --version\n\n\n\n\n프로젝트 만들기\n/home/user/docker-compose-test 디렉토리를 생성하고, 해당 디렉토리로 이동합니다.\n\n\ndocker-compose.yml 파일 작성\n\n\n\ndocker-compose.yml\n\nversion: '3'\n\nservices:\n  portainer:\n    image: portainer/portainer-ce:latest\n    container_name: portainer\n    restart: always\n    ports:\n      - \"8000:8000\"  # Portainer Agent 통신용\n      - \"9000:9000\"  # Portainer 웹 UI 접속용 (http://localhost:9000)\n      - \"9443:9443\"  # HTTPS 접속용\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - portainer_data:/data\n\nvolumes:\n  portainer_data:\n\n\n\n\n실행\n\n\n\nBash\n\ndocker compose up -d"
  },
  {
    "objectID": "posts/tools/dcm4chee.html#wsl2-ubuntu에서의-설치",
    "href": "posts/tools/dcm4chee.html#wsl2-ubuntu에서의-설치",
    "title": "DCM4chee",
    "section": "",
    "text": "https://github.com/dcm4che/dcm4chee-arc-light/wiki/Run-minimum-set-of-archive-services-on-a-single-host\n\n\n\n\ndocker compose랑 달라서 -이 있는 형태를 설치해야 합니다.\n\n\n\n\nbash\n\nsudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n\n\n\n\n\n\nslapd-dcm4chee, postgres-dcm4chee, dcm4chee-arc 매뉴얼 uid, gid가 999를 넘거나 이미 존재하고 있어, 옵션에 해당하는 이부분을 굳이 변경하여 문제를 일으킬 가능성을 고려하여 설정하지 않고 skip 하였습니다.\nsudo -i 명령으로 프롬프트가 #로 바뀔 수 있음을 주의해야 합니다.\n\n\n\n\nbash\n\n$ sudo -i\ngroupadd -r slapd-dcm4chee --gid=1021 && useradd -r -g slapd-dcm4chee --uid=1021 slapd-dcm4chee\ngroupadd -r postgres-dcm4chee --gid=999 && useradd -r -g postgres-dcm4chee --uid=999 postgres-dcm4chee\ngroupadd -r dcm4chee-arc --gid=1023 && useradd -r -g dcm4chee-arc --uid=1023 dcm4chee-arc\nexit\n\n\n\n\n\n\n\n\nbash\n\nmkdir dcm4chee\nch dcm4chee\n\n\n\n\n\n\n아래의 내용을 복사하여 dcm4chee 폴더에 docker-compose.yml로 저장합니다.\n매뉴얼에는 version이 있지만 불필요한 메세지만 생성되므로 삭제하였습니다.\n\n\n\n\ndocker-compose.yml\n\nservices:\n  ldap:\n    image: dcm4che/slapd-dcm4chee:2.6.7-33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"389:389\"\n    environment:\n      STORAGE_DIR: /storage/fs1\n    volumes:\n      - /var/local/dcm4chee-arc/ldap:/var/lib/openldap/openldap-data\n      - /var/local/dcm4chee-arc/slapd.d:/etc/openldap/slapd.d\n  db:\n    image: dcm4che/postgres-dcm4chee:17.1-33\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n     - \"5432:5432\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/db:/var/lib/postgresql/data\n  arc:\n    image: dcm4che/dcm4chee-arc-psql:5.33.1\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n    ports:\n      - \"8080:8080\"\n      - \"8443:8443\"\n      - \"9990:9990\"\n      - \"9993:9993\"\n      - \"11112:11112\"\n      - \"2762:2762\"\n      - \"2575:2575\"\n      - \"12575:12575\"\n    environment:\n      POSTGRES_DB: pacsdb\n      POSTGRES_USER: pacs\n      POSTGRES_PASSWORD: pacs\n      WILDFLY_CHOWN: /storage\n      WILDFLY_WAIT_FOR: ldap:389 db:5432\n    depends_on:\n      - ldap\n      - db\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /etc/timezone:/etc/timezone:ro\n      - /var/local/dcm4chee-arc/wildfly:/opt/wildfly/standalone\n      - /var/local/dcm4chee-arc/storage:/storage\n\n\n\n\n\n\n매뉴얼에서는 docker group에 user를 등록하여 문제가 없으나, 저자는 그러지 않았기 때문에 sudo를 하지 않으면 권한문제로 오류가 발생하므로 매뉴얼과 달리 아래와 같이 sudo로 설치해야 합니다.\n\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee up -d\n\n\n\n\n\nhttp://localhost:8080/dcm4chee-arc/ui2\nor\nhttps://localhost:8443/dcm4chee-arc/ui2",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/wsl2_ubuntu.html#설정",
    "href": "posts/tools/wsl2_ubuntu.html#설정",
    "title": "WSL2/Ubuntu",
    "section": "설정",
    "text": "설정\n\n/etc/wsl.conf\nsystemd의 설정을 true로 변경하여 systemd를 사용할 수 있도록 설정합니다.\n\n\n\n/etc/wsl.conf\n\n[boot]\nsystemd=true",
    "crumbs": [
      "Tools",
      "WSL2/Ubuntu"
    ]
  },
  {
    "objectID": "posts/tools/dcm4chee.html#제거",
    "href": "posts/tools/dcm4chee.html#제거",
    "title": "DCM4chee",
    "section": "제거",
    "text": "제거\n\n1차 제거\n\n\n\nbash\n\nsudo docker-compose -p dcm4chee down --rmi all --volumes --remove-orphans\n\n\n\n\n리소스 제거\n\n\n\nbash\n\nsudo docker system prune -a --volumes",
    "crumbs": [
      "Tools",
      "DCM4chee"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#window-운영체제에서의-설치",
    "href": "posts/tools/Orthanc.html#window-운영체제에서의-설치",
    "title": "Orthanc",
    "section": "Window 운영체제에서의 설치",
    "text": "Window 운영체제에서의 설치\n\n완전제거방법\n구동이 제대로 되지 않을 때가 많아서 완전제거방법을 조사하니 아래와 같았다.\n\n서비스 관리자에서 “Orthanc” 서비스를 찾아 중지합니다.\nC:\\Program Files\\Orthanc 폴더를 삭제합니다.\nC:\\Users\\&lt;username&gt;\\AppData\\Local\\Orthanc 폴더를 삭제합니다.\nOrthanc 설정 레지스트리 삭제 (Windows만 해당):\n\nregedit를 실행합니다.\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Orthanc 키를 삭제합니다.\n\n제어판에서 “프로그램 제거”를 선택하고 “Orthanc”를 제거합니다.\n\n\n\n설치파일\n공식사이트 https://orthanc.uclouvain.be/downloads/windows-64/installers/index.html 2025년 2월 27일 release된 25.2.0 버전이 최신이다.\n\n\n설치폴더\n기본설치폴더는 C:\\Program Files\\Orthanc Server이며 data는 C:\\Orthanc에 기본 설치된다. 이를 변경하면 Plugins에서 설치경로 인식의 문제 등으로 실행에 문제가 발생하는 것 같으므로 기본설치폴더에 설치하는 것이 좋겠다.\n\n\n설정파일\nmain 설정파일은 C:\\Program Files\\Orthanc Server\\Configuration\\orthanc.json이다.\n\n\nDICOMModality 설정\n매뉴얼(https://orthanc.uclouvain.be/book/integrations/modality.html#configure-modality)의 예시는 아래와 같았다.\n// The list of the known DICOM modalities\n\"DicomModalities\" : {\n  \"echo1\" : [ \"ECHO1\", \"123.124.125.10\", 104 ]\n},\n위를 참고하여 개발시스템의 DicomModality를 아래와 같이 설정하였다.\n  \"NMDOSE\" : [ \"NMDOSE\", \"127.0.0.1\", 5678 ],\n  \"NMIQ\" : [ \"NMIQ\", \"127.0.0.1\", 5679 ],\n  \"NMFULLDATA\" : [ \"NMFULLDATA\", \"127.0.0.1\", 5680 ],\n  \"NMTEMPSERVER\" : [ \"NMTEMPSERVER\", \"127.0.0.1\", 5681 ],\n  \"ZETTAPACS\" : [ \"ZETTAPACS\", \"127.0.0.1\", 5682 ],\n  \"SLICER\" : [ \"SLICER\", \"127.0.0.1\", 11112 ]\nconfiguration을 설정하는 동안에 Orthanc를 완전히 중지하였다가 수정 후 service를 재개하여야 수정사항이 반영됨을 주의해야 한다. 그리고 쓰기권한이 제한된 경우에는 이를 해결해야 한다.\n\n\nPort\n\n4242\n\n\n\nHPPT port\n\n8042\n\n\n\n설정\n\nPostgreSQL로 DICOM metadata를 저장하기 위해서 postgresql.json을 아래와 같이 설정하였다.\n\n{\n  \"PostgreSQL\" : {\n    \"EnableIndex\" : true,\n    \"EnableStorage\" : false,               // You likely don't need to enable this option\n    \"Host\" : \"localhost\",\n    \"Port\" : 5432,\n    \"Database\" : \"orthanc\",\n    \"Username\" : \"nmuser\",\n    \"Password\" : \"iloveben\",\n    \"Lock\" : true,\n    \"EnableSsl\" : false,                   // New in release 3.0\n    \"MaximumConnectionRetries\" : 10,       // New in release 3.0\n    \"ConnectionRetryInterval\" : 5,         // New in release 3.0\n    \"IndexConnectionsCount\" : 50,          // New in release 4.0 - new default value in 7.0\n    \"TransactionMode\": \"ReadCommitted\",    // New in release 6.0 - new default value in 7.0\n    \"EnableVerboseLogs\": false,            // New in release 6.0\n    \"HousekeepingInterval\": 1,             // New in release 7.0\n    \"AllowInconsistentChildCounts\": false  // New in release 7.2\n  }\n}",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#wsl2ubuntu-환경에서의-설치",
    "href": "posts/tools/Orthanc.html#wsl2ubuntu-환경에서의-설치",
    "title": "Orthanc",
    "section": "WSL2/Ubuntu 환경에서의 설치",
    "text": "WSL2/Ubuntu 환경에서의 설치\n\n패키지 목록 업데이트\n\n\n\nbash\n\nsudo apt update\n\n\n\n\nOrthanc 설치\n\n\n\nbash\n\nsudo apt install orthanc\n\n\n\n\nRemoteAccessAllowed 설정변경\n\n저자가 이해하기로는 내부에서가 아니라 외부에서 접속할 때 true로 설정해야 하는 것이지만 WSL2에서는 이 옵션을 true로 변경해야 가능한 것 같음\n\n\n\n\northanc.json\n\nsudo nano /etc/orthanc/orthanc.json\n\"RemoteAccessAllowed\" : true,\n\n\n\n\nOrthanc 재시작\n\n\n\nbash\n\nsudo systemctl restart orthanc\n\n\n\n\nOrthanc Explorer2 plugin 설치\n\n설치명령이 잘 작동하지 않아서 웹페이지에서 so 파일을 직접 다운로드 하였다.\n\n\n\n\nbrowse\n\nhttps://github.com/orthanc-server/orthanc-explorer-2/releases\n\n\n\nlibOrthancExplorer2-ubuntu.so 파일을 다운로드하여 /usr/share/orthanc/plugins 폴더에 저장하였다.\northanc.json에서 아래와 같이 설정하였다.\n\n\n\n\northanc.json\n\n\"Plugins\" : {\n  \"OrthancExplorer2\" : {\n    \"Enabled\" : true,\n    \"Path\" : \"/usr/share/orthanc/plugins/libOrthancExplorer2-ubuntu.so\"\n  }\n}\n\n\n\nOrthanc을 재시작하였다.\n\n\n\n\nbash\n\nsudo systemctl restart orthanc\n\n\n\n\n\nbash\n\nsudo apt install orthanc-explorer2\n\n\n\n\nWinddow와 통신설정\n\n윈도우는 host",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  },
  {
    "objectID": "posts/tools/Orthanc.html#스크립트",
    "href": "posts/tools/Orthanc.html#스크립트",
    "title": "Orthanc",
    "section": "스크립트",
    "text": "스크립트\n\nRetrieve 자동화\nOrthanc에 내장된 Lua engine으로 특정기간동안의 Modality==“PT”인 경우를 retrieve하도록 다음의 단계를 진행하였다. - orthanc.json에서 Lua script를 아래와 같이 활성화하였다.\n\"LuaScripts\" : [C:\\\\Orthanc\\\\lua\\\\retrieve_nm_studies.lua\"],\n그러나 query 요청에 실패해 일단 보류\ncurl -X POST http://localhost:8042/tools/execute-script --data-binary \"OnTimer()\"",
    "crumbs": [
      "Tools",
      "Orthanc"
    ]
  }
]